---
title: "spsurvey - Start Here"
author: "Michael Dumelle, Tony Olsen, Tom Kincaid, and Marc Weber"
output: 
  html_document:
    theme: flatly
    number_sections: true
    highlighted: default 
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
    toc_depth: 2
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE, 
  message = FALSE
)
library(tidyverse)
library(devtools)
load_all()
```

# Installing and Loading `spsurvey`

If this is your first time using the `spsurvey` package, you will need to run:
```{r, eval = FALSE}
install.packages("spsurvey")
```
to install the package. You only need to run this code once per version of R.

After the `spsurvey` package is installed, you must load it into R each time you start a new R session. To load the `spsurvey` package into R, run:
```{r setup, eval = FALSE}
library(spsurvey)
```


If you want to replicate the exact results in any of these vignettes at a later time, you will need to set a "seed" in your code just after the `library(spsurvey)` statement. To set this seed, run:
```{r}
set.seed(42)
```

# `sf` Objects

To obtain random samples using the algorithms in `spsurvey`, your data must be an `sf` object. An `sf` object, short for a "simple features" object, is an object with a unique structure used to conveniently store spatial data in R. `sf` objects are constructed using the `sf` package in R (Pebesma, 2018). The `sf` package is loaded and installed alongside the `spsurvey` package, so you do not need to run `install.packages("sf")` or `library(spsurvey)` to access the `sf` package if `spsurvey` is already installed and loaded. 

There are two commonly used ways to construct `sf` objects in R. The first is to read a shapefile directly into R using `st_read()` or `read_sf()`. The second is to use the `st_sf()` function or the `st_as_sf()` function to combine an appropriate R object (most commonly a data frame) and an appropriate geometry object into an `sf` object. For more information regarding `sf` objects, see Pebesma (2018) and Lovelace et al. (2019).

# Coordinate Reference Systems

Coordinate reference systems (CRS) identify a unique location on Earth's surface. CRSs are either geographic or projected. A geographic CRS uses longitude (east-west direction) and latitude (north-south direction) coordinates to represent location with respect to a specific ellipsoid or spheroid surface. Geographic CRSs are measured in degrees, *not meters*. This has important consequences; for example, a one degree difference in latitude is different at different longitudes. Projected CRSs are measured in standard cartesian coordinates with respect to a flat surface. They have x and y locations, an origin, and a unit of measurement (like meters). 

In R, CRS information has traditionally been stored as EPSG codes or proj4string values. This meant that in order to transform your coordinates from one CRS to another, you needed two EPSG codes or proj4strings: one for each CRS. With recent updates in R spatial that [follow GDAL and PROJ](https://www.r-spatial.org/r/2020/03/17/wkt.html), CRSs in `sf` are now stored in R as lists with two components, `input` and `wkt`, which contain information regarding the EPSG code and proj4string. For more information on CRSs and EPSG codes, see https://r-spatial.github.io/sf/index.html, Pebesma (2018), and Lovelace et al. (2019). To search for various coordinate reference systems and EPSG codes, visit https://spatialreference.org or https://epsg.io/ .

It is important that you use appropriate CRS in your `sf` object. If your CRS is mis-specified, you may get misleading results. `spsurvey` will use the coordinates in the geometry list-column stored in your `sf` object, so it is your responsibility to make sure they have the correct CRS.

# The Pipe Operator, `%>%`

The pipe operator, `%>%` from the `magrittr` R package (Bache and Wickham, 2014) is a useful tool for expressing a sequence of operations on a single object. Its primary benefit is making code easier to read and understand. The pipe operator comes pre-loaded when you load `spsurvey`.

Pipe operators are most commonly used with vectors or data frames. First, we use the pipe operator on a vector, and then we use it on a data frame. You can load the `NCCA_Gulf` data by running:
```{r}
data(NCCA_Gulf)
```
The `WGT_TP_EXTENT` variable contains `WGT_TP_EXTENT` value for several observations (THIS NEEDS CLARIFICATION). Suppose we want to compute the mean of the logarithm of `WGT_TP_EXTENT` values and then round to three decimal places. Without using the pipe operator, your code may look like this:
```{r}
log_extent <- log(NCCA_Gulf$WGT_TP_EXTENT)
mean_log_extent <- mean(log_extent)
round_mean_log_extent <- round(mean_log_extent, digits = 3)
round_mean_log_extent
```
The above code requires storage of each intermittent result -- this is inefficient only the final result, the rounded mean of the logarithm, is of interest! We could rewrite this code in one line:
```{r}
round_mean_log_extent <- round(mean(log(NCCA_Gulf$WGT_TP_EXTENT)), digits = 3)
round_mean_log_extent
```
While this code certainly saves space, it is hard to read because of the several nested operations.

The pipe operator helps to solve both of the problems above: it makes code easier to read and relieves the need to store every intermittent operation. Using the pipe operator, we can write:
```{r}
round_mean_log_extent <- NCCA_Gulf$WGT_TP_EXTENT %>% log() %>% mean() %>% round(digits = 3)
round_mean_log_extent
```
The pipe operator makes the sequence of operations clear: first we take the logarithm, then we take the mean, then we round to three significant digits. For long sequences, it is recommended to use a new line after each pipe to make the code more readable:
```{r}
NCCA_Gulf$WGT_TP_EXTENT %>% 
  log() %>% 
  mean() %>% 
  round(digits = 3)
```
There is no limit to the lines of code you can use, so don't be afraid to use multiple lines to make a sequence of operations easier to read. Future you will appreciate it when you come back to read your code after a break.

We can also use the pipe operator with data frames. The `BENTHIC_MMI` AND `BENTHIC_MMI_COND` variables in the `NCCA_Gulf` data contain raw `MMI` (Macroinvertebrate Multimetric Index) values and `MMI` condition classes (`Fair`, `Good`, `Not Assessed`, or `Poor`) for Benthic Macroinvertebrates. Suppose we want to subset the data to only contain these two variables and then compute a summary of each. Without the pipe operator, you could run
```{r}
sub_bmmi <- subset(NCCA_Gulf, select = c(BENTHIC_MMI, BENTHIC_MMI_COND))
summ_sub_bmmi <- summary(sub_bmmi)
summ_sub_bmmi
```
or
```{r}
summ_sub_bmmi <- summary(subset(NCCA_Gulf, select = c(BENTHIC_MMI, BENTHIC_MMI_COND)))
summ_sub_bmmi
```
But with the pipe operator, you only need to run
```{r}
summ_sub_bmmi <- NCCA_Gulf %>% 
            subset(select = c(BENTHIC_MMI, BENTHIC_MMI_COND)) %>%
            summary()
summ_sub_bmmi  
```

For a more through introduction to the pipe operator, see the "Pipes" chapter in Wickham and Grolemund (2017), which can be accessed for free online [here](https://r4ds.had.co.nz/index.html).


# References

Bache, S. M., Wickham, H. (2014). magrittr: A Forward-Pipe Operator for
  R. R package version 1.5. https://CRAN.R-project.org/package=magrittr

Lovelace, R., Nowosad, J., & Muenchow, J. (2019). Geocomputation with R. CRC Press.

Pebesma, E., (2018). Simple Features for R: Standardized Support for Spatial Vector Data. *The R Journal*, 10 (1):439-446. https://doi.org/10.32614/RJ-2018-009

Wickham, H., Grolemund, G. (2017). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (1st. ed.). O'Reilly Media, Inc.
