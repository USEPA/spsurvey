---
title: "Analyzing Probability Samples Using spsurvey (this needs a bit of work still timestamped 2/10 at 17:00"
author: "Michael Dumelle, Tony Olsen, Tom Kincaid, and Marc Weber"
output: 
  html_document:
    theme: flatly
    number_sections: true
    highlighted: default 
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
    toc_depth: 1
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE, 
  message = FALSE
)
library(devtools)
load_all()
data("NLA_West")
```


# Introduction

In this vignette, you will use `spsurvey` to analyze probability samples of a finite resource. You will analyze categorical variables using the `cat_analysis()` function, and you will analyze continuous variables using the `cont_analysis()` function. There are several required arguments to the `cat_analysis()` and `cont_analysis()` functions.

* `dframe`: A design frame (which can be a data frame, `sp` object, or `sf` object) containing variables whose names match those from the `vars`, `siteid`, `weight`, `xcoord`, and `ycoord` arguments.
* `vars`: A character string indicating the name(s) of the response variable(s) in `dframe` to be analyzed.
* `siteid`: A character string indicating the name of the site indicator variable in `dframe`.
* `weight`: A character string indicating the name of the survey design weights variable in `dframe`.
* `xcoord`: A character string indicating the name of the x-coordinate variable in `dframe`. 
* `ycoord`: A character string indicating the name of the y-coordinate variable in `dframe`.

There are two types of data objects that can be used with `cat_analysis()`: an `sf` object or a standard `data.frame`. If an `sf` object is used, the `xcoord` and `ycoord` arguments to the `cat_analysis()` and `cont_analysis()` functions are not required. There are several other optional arguments available to `cat_analysis()` and `cont_analysis()` that provide further customization of your analysis; you can run `?cat_analysis()` and `?cont_analysis()` for more information.

Before using these analysis functions, we can summarize our data after turning it into an `sframe` object:
```{r}
NLA_West <- dframe(NLA_West)
```

Suppose we wanted to summarize the number of sampled lakes that were from the target population (`TNT_CAT`):
```{r}
summary(NLA_West, ~ TNT_CAT)
```

Next, you will explore:

* [The `NLA_West` Data (point resources)]
* [The `NRSA_EPA7` Data (linear resources)]
* [The `NCCA_Gulf` Data (areal resources)]

If you have not yet done so, please read the "Start Here" vignette, accessed [here](dummy link for now) or by running `vignette("start_here", package = "spsurvey")`. 

# The `NLA_West` Data (point resources)

Before anything else, you must load `spsurvey` by running
```{r setup, eval = FALSE}
library(spsurvey)
```

Then, you can load the `NLA_West` data by running 
```{r}
data("NLA_West")
```

There are a few missing values in this data, so you can remove them before proceeding
```{r}
NLA_West <- na.omit(NLA_West)
```


## `cat_analysis()`

The `cat_analysis()` function returns a data frame containing a suite of information regarding the categorical variable in question. Each row contains information regarding several variables:

* `Type`: The variable type. If no subpopulations are analyzed, this will correspond to all sites. If a subpopulation is analyzed, this will correspond to the name of the subpopulation variables.
* `Subpopulation`: The level of the subpopulation variable.
* `Indicator`: The indicator variable analyzed.
* `Category`: The level of the indicator variable.
* `nResp`: The number of samples.
* `Estimate.P`: The estimated proportion of population units in this `Category`.
* `StdError.P`:  The standard error for `Estimate.P`.
* `MarginofError.P`: The margin of error for `Estimate.P`.
* `LCB95Pct.P`: The lower bound of a 95% confidence interval for `Estimate.P`.
* `UCB95Pct.P`: The upper bound of a 95% confidence interval for `Estimate.P`.
* `Estimate.U`: The estimated total of population units in this `Category`.
* `StdError.U`:  The standard error for `Estimate.U`.
* `MarginofError.U`: The margin of error for `Estimate.U`.
* `LCB95Pct.U`: The lower bound of a 95% confidence interval for `Estimate.U`.
* `UCB95Pct.U`: The upper bound of a 95% confidence interval for `Estimate.U`.

First you will estimate the extent (numbers of lakes) that are in the target population.
```{r}
tnt_extent <- cat_analysis(
  dframe = NLA_West,
  vars = "TNT_CAT",
  weight = "WGT_TP_EXTENT",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE
)
print(tnt_extent)
```

The `popcorrect` argument indicates that a finite population adjustment to the variance estimate should be calculated.

Next, you will subset the data to only include lakes in the target population:
```{r}
NLA_West_Target <- subset(NLA_West, TNT_CAT == "Target")
```

Then you can analyze the phosphorus condition class (`PHOSPHORUS_COND`) by running
```{r}
phos_cond <- cat_analysis(
  dframe = NLA_West_Target,
  vars = "PHOSPHORUS_COND",
  weight = "WGT_TP_CORE",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE,
)
print(phos_cond)
```

To analyze the phosphorus condition class for the urban vs non-urban subpopulation (`URBN_NLA17`), run
```{r}
phos_cond2 <- cat_analysis(
  dframe = NLA_West_Target,
  vars = "PHOSPHORUS_COND",
  weight = "WGT_TP_CORE",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE
)
print(phos_cond2)
```

## `cont_analysis()`

To analyze Benthic MMI (`BENTHIC_MMI`), run
```{r}
bmmi <- cont_analysis(
  dframe = NLA_West_Target,
  vars = "BENTHIC_MMI",
  weight = "WGT_TP_CORE",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE
)
```

To view the first few rows of each type of output, run
```{r}
head(bmmi$CDF)
head(bmmi$Pct)
```

To analyze Benthic MMI (`BENTHIC_MMI`) for the urban vs non-urban subpopulation (`URBN_NLA17`), run

```{r}
bmmi2 <- cont_analysis(
  dframe = NLA_West_Target,
  vars = "BENTHIC_MMI",
  weight = "WGT_TP_CORE",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE
)
```

To view the first few rows of each type of output, run
```{r}
head(bmmi2$CDF)
head(bmmi2$Pct)
```

# The `NRSA_EPA7` Data (linear resources)

You can load the `NRSA_EPA7` data by running 
```{r}
data("NRSA_EPA7")
```

There are a few missing values in this data, so you can remove them before proceeding
```{r}
NRSA_EPA7 <- na.omit(NRSA_EPA7)
```

There are a few missing values in this data, so you can remove them before proceeding
```{r}
NRSA_EPA7 <- na.omit(NRSA_EPA7)
```

First you will estimate the extent (total sreatm length) that are in the target population.
```{r}
tnt_extent <- cat_analysis(
  dframe = NRSA_EPA7,
  vars = "TNT_CAT",
  weight = "WGT_TP_EXTENT",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE
)
print(tnt_extent)
```

The `popcorrect` argument indicates that a finite population adjustment to the variance estimate should be calculated.

Next, you will subset the data to only include lakes in the target population:
```{r}
NRSA_EPA7_Target <- subset(NRSA_EPA7, TNT_CAT == "Target")
```

Then you can analyze the phosphorus condition class (`PHOSPHORUS_COND`) by running
```{r}
phos_cond <- cat_analysis(
  dframe = NRSA_EPA7_Target,
  vars = "PHOSPHORUS_COND",
  weight = "WGT_TP_CORE",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE,
)
print(phos_cond)
```

## `cont_analysis()`

To analyze Benthic MMI (`BENTHIC_MMI`), run
```{r}
bmmi <- cont_analysis(
  dframe = NRSA_EPA7_Target,
  vars = "BENTHIC_MMI",
  weight = "WGT_TP_CORE",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE
)
```

To view the first few rows of each type of output, run
```{r}
head(bmmi$CDF)
head(bmmi$Pct)
```

To analyze Benthic MMI (`BENTHIC_MMI`) for the urban vs non-urban subpopulation (`URBN_NLA17`), run

```{r}
bmmi2 <- cont_analysis(
  dframe = NRSA_EPA7_Target,
  vars = "BENTHIC_MMI",
  weight = "WGT_TP_CORE",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE
)
```

To view the first few rows of each type of output, run
```{r}
head(bmmi2$CDF)
head(bmmi2$Pct)
```

# The `NCCA_Gulf` Data (areal resources)

You can load the `NCCA_Gulf` data by running 
```{r}
data("NCCA_Gulf")
```

There are a few missing values in this data, so you can remove them before proceeding
```{r}
NCCA_Gulf <- na.omit(NCCA_Gulf)
```

There are a few missing values in this data, so you can remove them before proceeding
```{r}
NCCA_Gulf <- na.omit(NCCA_Gulf)
```

First you will estimate the extent (total sreatm length) that are in the target population.
```{r}
tnt_extent <- cat_analysis(
  dframe = NCCA_Gulf,
  vars = "TNT_CAT",
  weight = "WGT_TP_EXTENT",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE
)
print(tnt_extent)
```

The `popcorrect` argument indicates that a finite population adjustment to the variance estimate should be calculated.

Next, you will subset the data to only include lakes in the target population:
```{r}
NCCA_Gulf_Target <- subset(NCCA_Gulf, TNT_CAT == "Target")
```

Then you can analyze the phosphorus condition class (`PHOSPHORUS_COND`) by running
```{r}
phos_cond <- cat_analysis(
  dframe = NCCA_Gulf_Target,
  vars = "PHOSPHORUS_COND",
  weight = "WGT_TP_CORE",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE,
)
print(phos_cond)
```


## `cont_analysis()`

To analyze Benthic MMI (`BENTHIC_MMI`), run
```{r}
bmmi <- cont_analysis(
  dframe = NCCA_Gulf_Target,
  vars = "BENTHIC_MMI",
  weight = "WGT_TP_CORE",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE
)
```

To view the first few rows of each type of output, run
```{r}
head(bmmi$CDF)
head(bmmi$Pct)
```

To analyze Benthic MMI (`BENTHIC_MMI`) for the urban vs non-urban subpopulation (`URBN_NLA17`), run

```{r}
bmmi2 <- cont_analysis(
  dframe = NCCA_Gulf_Target,
  vars = "BENTHIC_MMI",
  weight = "WGT_TP_CORE",
  xcoord = "XCOORD",
  ycoord = "YCOORD",
  popcorrect = TRUE
)
```

To view the first few rows of each type of output, run
```{r}
head(bmmi2$CDF)
head(bmmi2$Pct)
```