---
title: "Selecting Spatially Balanced Samples from a Point Network (Finite Population)"
author: "Michael Dumelle, Tony Olsen, Tom Kincaid, and Marc Weber"
output: 
  html_document:
    theme: flatly
    number_sections: true
    highlighted: default 
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Selecting Spatially Balanced Samples from a Point Network (Finite Population)}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE, 
  message = FALSE
)
```

# Introduction

In this vignette, you will use `spsurvey` to select probability samples using the the GRTS algorithm (Stevens and Olsen, 2004) and independent (simple) random sampling. A greater focus will be placed on GRTS, as this algorithm yields samples having "spatial balance." More specifically, throughout this vignette, you will explore:

* [The `NE_Lakes` Data] 
* [GRTS Designs]
    * [An Unstratified, Equal Probability GRTS Design] 
    * [An Unstratified, Unequal Probability GRTS Design]
    * [A Stratified, Equal Probability GRTS Design]
    * [A Stratified, Proportional Probability GRTS Design]
* [Independent Random Sampling Designs]
* [Additional Design Features]
    * [Legacy Sites]
    * [Minimum Distance Between Sites]
    * [Replacement Sites]
* [Calculating the Spatial Balance of a Sample]

If you have not yet done so, please stop and read the "Start Here" vignette, accessed by running `vignette("start_here", package = "spsurvey")`. 

# The `NE_Lakes` Data

Before anything else, you must load `spsurvey` by running
```{r}
library(spsurvey)
```

If you want to reproduce the results from code in this vignette, you must also set a seed by running
```{r}
set.seed(5.0)
```

Throughout this vignette, you will use select probability samples from the `NE_Lakes` data set. The `NE_Lakes` data set is composed of 5328 lakes in the Southern New England Region of the United States. To load the data into R, run
```{r}
data("NE_Lakes")
```

To view the first few rows, run
```{r}
head(NE_Lakes)
```
You will notice that along with attributes, spatial information has been returned for the data:

* `geometry type`: This is a `POINT` geometry because each lake has a set of `x` and `y` coordinates.
* `dimension`: There are two dimensions, `X` (east-west) and `Y` (north-south).
* `bbox`: The bounding box of the spatial locations.
* `projected CRS`: The coordinates in a USA Contiguous Albers Equal Area Conic Projection.

The next few lines describe variables in `NE_Lakes`; for more regarding the `NE_Lakes` data and associated variables, run `?NE_Lakes`.

We'll later summarize and visualize the `NE_Lakes` data. But before doing so, we need store the data as an `sframe` (short for "sample frame") object:
```{r}
NE_Lakes <- sframe(NE_Lakes)
```

Next we give an overview of GRTS designs and visualize the `NE_Lakes` data.

# GRTS Designs

In this section, we'll demonstrate spatially balanced samples -- but what exactly is a "spatially balanced sample?" And why are they important? Stevens and Olsen (2004) defined a spatially balanced sample as a sample mirroring the density of the population -- this is often referred to as a sample that is a *miniature* of the population. This is different from spatial balance with respect to geography, in which samples may be evenly spread relative to the geography studied. To elucidate this distinction, consider the following plot of the `NE_Lakes` locations:
```{r, fig.align = "center", fig.cap = "Locations of lakes in the `NE_Lakes` data."}
plot(NE_Lakes)
```

Notice that lake density is slightly higher to the northeast than in the northwest. A spatially balanced sample with respect to the population mirrors the density in the population and would select more samples in the northeast then the northwest, while a spatially balanced sample with respect to geography omits this density information but takes into account absolute distances among neighboring sites. These two types of spatial balance are useful in different contexts, and neither is superior over the other. But it is important to be aware of this distinction and its implications. Henceforth, when we refer to **spatial balance**, we mean spatial balance with respect to the population.

Spatially balanced samples are useful because they tend to yield estimators of means and totals *having narrower confidence intervals* than samples lacking spatial balance. This means our estimators are more *precise*, which can lead to reduced resource costs and a *more accurate representation* of the true, unknown values of the quantities we are studying.

We will use the `grts()` function in spsurvey to select our spatially balanced samples. For more detailed information than what you will learn in this vignette, run `?grts`.

## An Unstratified, Equal Probability GRTS Design

To select an unstratified, equal probability GRTS sample, run
```{r}
# selecting a sample using an equal probability design
eqprob <- grts(sframe = NE_Lakes, seltype = "equal", n_base = 60)
```

* `sframe` (sample frame) is the `NE_Lakes` data.
* `seltype` is `"equal"` for equal selection probabilities.
* `n_base` is 60, the desired sample size.

`eqprob` contains an `sf` object, `eqprob$sites_base`, with the selected sites. To view the first few rows, run
```{r}
head(eqprob$sites_base)
```

There are several variables contained in `eqprob$sites_base`:

* `siteID` is a unique site identification code for each site in the sample
* `siteuse` is equal to "Base" since all sites are expected to be sampled
* `replsite` is equal to "None" since no over sample sites were selected
* `stratum` indicates each site's strata; for this unstratified design, all entries in `stratum` are `"None"` because there are no strata
* `wgt` is the site's survey design weight (in units of the sf object geometry)
* `ip` is the site's original inclusion probability (in inverse units of the sf object geometry)
* `caty` indicates each site's unequal probability grouping; for this equal probability design, all entries in `caty` are `"None"`.
* Several other variables have `NA` values -- this just means they are not relevant to your design and can be ignored for now.

To overlay the spatially balanced sample on the original population, run
```{r, fig.align = "center", fig.cap = "Population (`sframe`) and sampled sites (`sites_base`) from an equal probability GRTS design."}
plot(eqprob, NE_Lakes, pch = 19, key.pos = 1)
```

The `pch = 19` argument tells `spsurvey` to plot closed circles instead of open circles (the default), and the `key.pos = 1` argument tells `spsurvey` to put the legend at the bottom of the plot (as opposed to the right side, the default).

`grts` returns several design elements used by the function as a tool to both keep track of and to verify the specifications of your design. You can access this information by running `eqprob$dsgn`. A list is printed containing several pieces of information -- several of which may be `NULL`. These `NULL` values are expected and change based on the specifications of your design, similar to how the columns having only `NA` in `eqprob$sites_base` will eventually change; this will be made more clear later on. For now, you will focus on the relevant non-`NULL` information:
```{r, echo = FALSE}
for (s in names(eqprob$design)) {
    if (length(Filter(Negate(is.null), 
                      eqprob$design[[s]])) == 0) eqprob$design[[s]] <- NULL
}
eqprob$design
```

* The `Call` is the original function call you supplied to `grts()`, making explicit the names of the arguments if specified via defaults.
* The `stratum` variable (the `stratum_var` argument to `grts()`) in `eqprob$sites_base` is given the name `stratum`
* All entries in `stratum` are given the same value: `"None"`
* The selection type for the `"None"` stratum is "equal" probability
* There are 60 (`n_base`) samples in the `"None"` stratum

## A Stratified, Equal Probability GRTS Design

Suppose we wish to sample the lakes in the high elevation group with a higher probability than lakes in the low elevation group. First it is helpful to summarize lakes in each elevation category:
```{r}
summary(NE_Lakes, ~ ELEVATION_CAT)
```

There are 5328 total  lakes, 3257 of which are in the low elevation category and 2071 of which are in the high elevation category. Next, you can plot the lakes in each elevation category:
```{r, fig.align = "center", fig.cap = "Population sites by `ELEVATION_CAT`."}
plot(NE_Lakes, formula = ~ ELEVATION_CAT, key.pos = 1)
```

Stratified designs ensure each within-group sample size equals the expected sample size. To select a spatially balanced, stratified design having equal probabilities of selection within each elevation group, run
```{r}
# sample sizes of the strata
strata_n <- c(low = 30, high = 30)
# selecting the stratified, equal probability sample
strat_eqprob <- grts(
  sframe = NE_Lakes,
  stratum_var = "ELEVATION_CAT",
  seltype = "equal", 
  n_base = strata_n
)
```

* `seltype` is "equal" for equal selection probabilities within strata.
* `stratum_var` matches the name of the variable in `NE_Lakes` containing the strata.
* `n_base` is a names vector whose names identify strata and whose values indicate the within-strata sample sizes.

The relevant non-NULL `dsgn` output is
```{r, echo = FALSE}
strat_eqprob$design$legacy_option <- NULL
for (s in names(strat_eqprob$design)) {
    if (length(Filter(Negate(is.null), strat_eqprob$design[[s]])) == 0) strat_eqprob$design[[s]] <- NULL
}
strat_eqprob$design
```

To visualize the GRTS sample for each stratum, run
```{r, fig.align = "center", fig.cap = "Population (sframe) and sampled sites (sites_base) obtained for the two `ELEVATION` strata using a stratified GRTS design with equal selection probabilities within strata."}
plot(
  strat_eqprob,
  NE_Lakes,
  sites ~ ELEVATION_CAT,
  pch = 19,
  key.pos = 1
)
```

## An Unstratified, Unequal Probability GRTS Design

Suppose we wish to sample the lakes in the highest elevation group with a higher probability than all other lakes but do not want to explicitly stratify. First it is helpful to summarize lakes in each elevation category:
```{r}
summary(NE_Lakes, ~ ELEVATION_CAT)
```

There are 5328 total  lakes, 3257 of which are in the low elevation category and 2071 of which are in the high elevation category. Next, you can plot the lakes in each elevation category:
```{r, fig.align = "center", fig.cap = "Population sites by `ELEVATION_CAT`."}
plot(NE_Lakes, formula = ~ ELEVATION_CAT, key.pos = 1)
```

To select an unequal probability GRTS sample by elevation group, run
```{r}
# expected sample size for each group with names
caty_n <- c(low = 20, high = 40)
# selecting the unequal probability sample
uneqprob <- grts(
  sframe = NE_Lakes,
  seltype = "unequal",
  n_base = 60,
  caty_var = "ELEVATION_CAT",
  caty_n = caty_n
)
```

* `seltype` is "unequal" for selecting a sample with unequal probability by groups.
* `n_base` is the desired **total** sample size, 60.
* `caty_var` matches the name of the variable in `NE_Lakes` with the unequal probability groups.
* `caty_n` is a vector with expected sample sizes for each group in `caty_var`.
    * The names of `caty_n` must match the names of each group in `caty_var`.
    * The sum of `caty_n` values must equal `n_base`.

Though the expected sample sizes for this design are specified by `caty_n`, there is no guarantee your within-group sample sizes will match these values **exactly**.

The relevant non-NULL `dsgn` output is
```{r, echo = FALSE}
uneqprob$dsgn$legacy_option <- NULL
for (s in names(uneqprob$design)) {
    if (length(Filter(Negate(is.null), 
                      uneqprob$design[[s]])) == 0) uneqprob$design[[s]] <- NULL
}
uneqprob$design
```

## A Stratified, Proportional Probability GRTS Design

We can alter the previous design to accommodate proportional probability sampling within strata where each stratum's sample is proportional to lake area (in hectares; `AREA_HA`); larger lakes have a higher probability of being sampled.These types of designs are useful when the response variable you plan to collect is positively correlated with the auxiliary variable; in this case, the proportional probability design is **more efficient** than a design with equal selection probabilities within strata. Before implementing this design, we can summarize total `AREA_HA` within each `ELEVATION_CAT` category:
```{r}
summary(NE_Lakes, AREA_HA ~ ELEVATION_CAT)
```

To use the proportional probability design, run
```{r}
# sample sizes of the strata
strata_n <- c(low = 30, high = 30)
# selecting the stratified, unequal probability sample
strat_uneqprob <- grts(
  sframe = NE_Lakes,
  stratum_var = "ELEVATION_CAT",
  n_base = strata_n,
  seltype = "proportional", 
  aux_var = "AREA_HA"
)
```

* `stratum_var` matches the name of the variable in `NE_Lakes` containing the strata.
* `n_base` is a named vector whose names identify strata and whose values indicate the sample size for each stratum.
* `seltype` is "proportional" for proportional selection probabilities within each stratum.
* `aux_var` matches the name of the variable in `NE_Lakes` to sample proportionally by.
    * This variable must be *strictly positive* (all lakes have positive areas)
    
The relevant non-NULL `dsgn` output is:
```{r, echo = FALSE}
strat_uneqprob$design$legacy_option <- NULL
for (s in names(strat_uneqprob$design)) {
    if (length(Filter(Negate(is.null), strat_uneqprob$design[[s]])) == 0) strat_uneqprob$design[[s]] <- NULL
}
strat_uneqprob$design
```

# Independent Random Sampling Designs

If you want to conduct an independent random sample (IRS) instead of a GRTS sample, simply replace the `grts()` function with the `irs()` function. All of the arguments are identical, so any of the aforementioned examples can be easily applied to the IRS scenario as well. For example, to select an equal probability IRS, run
```{r}
# equal probability design
eqprob_irs <- irs(sframe = NE_Lakes, seltype = "equal", n_base = 60)
```

The relevant non-`NULL` design output is
```{r, echo = FALSE}
eqprob_irs$design$legacy_option <- NULL
for (s in names(eqprob_irs$design)) {
    if (length(Filter(Negate(is.null), 
                      eqprob_irs$design[[s]])) == 0) eqprob_irs$design[[s]] <- NULL
}
eqprob_irs$design
```

To overlay the sample on the original population, run
```{r, fig.align = "center", fig.cap = "Population (`sframe`) and sampled sites (`sites_base`) obtained for an equal probability IRS design."}
plot(eqprob_irs, NE_Lakes, pch = 19, key.pos = 1)
```

Notice how several of the sampled locations are closer together than they were for the unstratified, equal probability GRTS design, especially in the southwestern part of the map.

# Additional Design Features

Besides selection probability type and stratification, there are several other design features `grts()` and `irs()` functions can accommodate (though we focus on applying the `grts()` function here): [Legacy Sites], [Minimum Distance Between Sites], and [Replacement Sites]. 

## Legacy Sites

Researchers may want to ensure that a specific set of sites are always in the sample; these sites are known as legacy sites.  Legacy sites are commonly selected as part of a previous probability sample, and this is the scenario for which we focus.  The variable, `LEGACY`, in `NE_Lakes` identifies five randomly selected legacy sites that are to be included in a new design.

To include legacy sites in an unstratified, equal probability sample, run
```{r}
eqprob_legacy <- grts(
  NE_Lakes,
  seltype = "equal",
  n_base = 60,
  legacy_var = "LEGACY"
)
```

* `seltype` is `"equal"` for an equal probability design
* `n_base` is 60, the desired sample size
* `legacy_var` matches the name of the variable in `NE_Lakes` specifying legacy sites

The relevant non-null design output is
```{r, echo = FALSE}
for (s in names(eqprob_legacy$design)) {
    if (length(Filter(Negate(is.null), eqprob_legacy$design[[s]])) == 0) eqprob_legacy$design[[s]] <- NULL
}
eqprob_legacy$design
```

To plot the base sites separately from the legacy sites (without the sample frame), run
```{r}
plot(
  eqprob_legacy,
  sites = c("sites_base"),
  showlegacy = TRUE,
  pch = 19,
  key.pos = 1
)
```

With some data, you may encounter a warning message saying `Of the x grid cells from which sample points were selected, y (y/x%) of the cells contained more than one sample point. This warning message exists because sometimes the requirement that legacy sites must be included prevents the sample from being as spatially balanced as a sample from a standard application of the GRTS algorithm. 

## Minimum Distance Between Sites

The standard GRTS algorithm may select sites that are closer together than desired. You can adjust the algorithm to require a minimum distance between sites.  Suppose we require sites to be 5,000 meters ($\approx$ 3 miles) apart. To include this requirement in an unstratified, equal probability design, run
```{r}
# setting the minimum distance
eqprob_mindis <- grts(
  NE_Lakes,
  seltype = "equal",
  n_base = 60,
  mindis =5000
)
```

* `seltype` is `"equal"` for equal selection probabilities.
* `n_base` is 60, the desired sample size.
* `mindis` is the minimum distance desired between sites. Note: must be in same units as sf object geometry.

The relevant non-`NULL` design output is
```{r, echo = FALSE}
eqprob_mindis$design$legacy_option <- NULL
for (s in names(eqprob_mindis$design)) {
    if (length(Filter(Negate(is.null), eqprob_mindis$design[[s]])) == 0) eqprob_mindis$design[[s]] <- NULL
}
eqprob_mindis$design
```

To plot the population sites next to the sampled sites, run
```{r, fig.align = "center", fig.cap = "Population (`sframe`) and sampled (`sites_base`) sites for an equal probability GRTS design having a minimum distance between sites of 5,000 meters."}
plot(eqprob_mindis, NE_Lakes, pch = 19)
```

It is possible that the GRTS algorithm will not be able to ensure the minimum distance is met for all sampled sites.  In this context, the algorithm will attempt to ensure the minimum distance is met for as many sites as possible and return a warning stating that the requirement was not met after several iterations of the algorithm.

## Replacement Sites

It is often the case that a selected site is unable to be sampled. This can happen for a variety of reasons: landowner denial, lack of funding, or lack of resources, to name a few. If you expect there are sites you may not be able to sample, you can include potential replacement sites in your GRTS design. `spsurvey` gives you two methods to select these replacement sites: reverse hierarchical ordering and nearest neighbor.

### Reverse Hierarchical Ordering

First, we discuss reverse hierarchical ordering replacement. In this context, the number desired sample size, $n$, and the number of replacement sites, $n_r$, must be specified before the design is selected. A standard GRTS algorithm is used to select a sample of size $n + n_r$. Then, these sites are placed into "reverse hierarchical order" and the $n$ base sites and $n_r$ replacement sites are classified. The $n$ base sites should be sampled first and if any are unable to be sampled, the replacement sites are to be used. For more details, see Stevens and Olsen (2004). To select a GRTS sample of size 60 with 10 reverse hierarchical ordering replacement sites, run
```{r}
eqprob_rho <- grts(NE_Lakes, seltype = "equal", n_base = 60, n_over = 10)
```

* `seltype` is `"equal"` for equal selection probabilities.
* `n_base` is 60, the desired sample size.
* `n_over` is the number of desired reverse hierarchical ordering replacement sites.

`eqprob_rho$sites_base` is the `sf` object containing the $n$ base sites, and `eqprob_reverse$sites_over` is the `sf` object containing the $n_r$ replacement sites. The relevant non-`NULL` design output is
```{r, echo = FALSE}
eqprob_rho$design$legacy_option <- NULL
for (s in names(eqprob_rho$design)) {
    if (length(Filter(Negate(is.null), eqprob_rho$design[[s]])) == 0) eqprob_rho$design[[s]] <- NULL
}
eqprob_rho$design
```

To plot the population sites next to the sampled sites and the replacement sites, run
```{r, fig.show = "hold", fig.align = "center", fig.cap = "Population sites (`sframe`), sampled sites (`sites_base`), and replacement sites (`sites_over`) for an equal probability GRTS design using reverse hierarchical ordering for the replacement sites."}
plot(eqprob_rho, NE_Lakes, pch = 19, key.pos = 1)
```

### Nearest Neighbor

The second method for selecting replacement sites is the nearest neighbor method. A base GRTS sample of size $n$ is first selected. If a site is then unable to be sampled, the nearest neighbor method provides $n_r$ (up to 10) replacement sites that are closest to the original, unsampled site. This implies that for each site in the GRTS sample, $n_r$ replacement sites are available. To select a GRTS sample of size 60 with 2 nearest neighbors for each site, run
```{r}
eqprob_nn <- grts(
  NE_Lakes,
  seltype = "equal",
  n_base = 60,
  n_near = 2
)
```

* `seltype` is `"equal"` for equal selection probabilities.
* `n_base` is 60, the desired sample size.
* `n_near` is the number of nearest neighbor replacement sites desired for each base site.

`eqprob_rho$sites_base` is the `sf` object containing the $n$ base sites, and `eqprob_reverse$sites_near` is the `sf` object containing the $n_r$ replacement sites. The relevant non-`NULL` design output is
```{r, echo = FALSE}
eqprob_nn$design$legacy_option <- NULL
for (s in names(eqprob_nn$design)) {
    if (length(Filter(Negate(is.null), eqprob_nn$design[[s]])) == 0) eqprob_nn$design[[s]] <- NULL
}
eqprob_nn$design
```

To view the population sites, base sample sites, and each sampled site's nearest replacement site, run
```{r, fig.show = "hold", fig.align = "center", fig.cap = "Population sites (`sframe`), sampled sites (`sites_base`), and replacement sites (`sites_near`) for an equal probability GRTS design using nearest neighbors for the replacement sites."}
plot(eqprob_nn, NE_Lakes, pch = 19, key.pos = 1)
```
You will notice that these replacement sites are very close to the originally sampled sites.

To view the geometries of the sampled sites and replacement sites individually, run
```{r, fig.show = "hold", fig.align = "center", fig.cap = "Geometries for the base sites (`sites_base`) and replacement sites (`sites_near`) for an equal probability GRTS design using nearest neighbors for the replacement sites."}
plot(
  eqprob_nn,
  NE_Lakes,
  sites = c("sites_base", "sites_near"),
  geom = TRUE,
  pch = 19,
)
```


# Calculating the Spatial Balance of a Sample

To measure the spatial balance of a design, Stevens and Olsen (2004) proposed using a set of Voronoi polygons. The Voronoi polygon for a sampled site contains all population sites closer to this sampled site than any other sampled site. The set of Voronoi polygons for all sampled sites will contain all population sites. If a sample is spatially balanced, we would expect that the proportion of total population sites in each Voronoi polygon to be approximately $1/n$.

Let $p_i$ be the proportion of population sites in Voronoi polygon $i$. The Pielou's evenness index is often used as a measure of spatial balance and can be defined as $1 + \frac{1}{n}\sum_{i = 1}^n p_i log(p_i)$. One attractive feature of Pielou's evenness index is that it is unitless; a value of 0 indicates perfect spatial balance, and a value of 1 indicates no spatial balance. To compute the Pielou's evenness index of the equal probability GRTS and IRS designs, run
```{r}
# compute for grts
pielou_grts <- spbalance(eqprob$sites_base, NE_Lakes)
pielou_grts
# compute for irs
pielou_irs <- spbalance(eqprob_irs$sites_base, NE_Lakes)
pielou_irs
```

Unsurprisingly, the GRTS design has better spatial balance than the IRS design. By default, `spbalance()` computes only the Pielou's evenness index, but several other spatial balance metrics are available -- run `?spbalance` for more information.

# References

Stevens Jr, D. L. and Olsen, A. R. (2004). Spatially balanced sampling of natural resources.
*Journal of the American Statistical Association*, 99(465):262-278.