################################################################################
# Function: relrisk_analysis
# Programmer: Tom Kincaid
# Date: July 16, 2020
#'
#' Relative Risk Analysis for Probability Survey Data
#'
#' This function organizes input and output for relative risk analysis of
#' categorical data generated by a probability survey.
#'
#' @param dframe Data frame containing survey design variables, response
#'   variables, stressor variables, and subpopulation (domain) variables.
#'
#' @param vars_response Vector composed of character values that identify the
#'   names of response variables in the dframe data frame.
#'
#' @param vars_stressor Vector composed of character values that identify the
#'   names of stressor variables in the dframe data frame.
#'
#' @param response_levels List providing the category values (levels) for each
#'   element in the vars_response argument.  This argument should be named and
#'   must be the same length as argument vars_response.  The first level for
#'   each element in the list is used for calculating the numerator and the
#'   denominator of the relative risk estimate.  The default is a list
#'   containing the values "Poor" and "Good" for the first and second levels,
#'   respectively, of each element in the vars_response argument.
#'
#' @param stressor_levels List providing the category values (levels) for each
#'   element in the vars_stressor argument.  This argument should be named and
#'   must be the same length as argument vars_response.  The first level for
#'   each element in the list is used for calculating the numerator of the
#'   relative risk estimate, and the second level for each element in the list
#'   is used for calculating the denominator of the estimate.  The default is a
#'   list containing the values "Poor" and "Good" for the first and second
#'   levels, respectively, of each element in the vars_stressor argument.
#'
#' @param subpops Vector composed of character values that identify the
#'   names of subpopulation (domain) variables in the dframe data frame.  If a
#'   value is not provided, the value "All_Sites" is assigned to the subpops
#'   argument and a factor variable named "All_Sites" that takes the value
#'   "All Sites" is added to the dframe data frame.  The default value is NULL
#'
#' @param siteID Character value providing name of the site ID variable in
#'   the dframe data frame.  For a two-stage sample, the site ID variable
#'   identifies stage two site IDs.  The default value is "siteID".
#'
#' @param weight Character value providing name of the survey design weight
#'   variable in the dframe data frame.  For a two-stage sample, the weight
#'   variable identifies stage two weights.  The default value is "weight".
#'
#' @param xcoord Character value providing name of the x-coordinate variable in
#'   the dframe data frame.  For a two-stage sample, the x-coordinate variable
#'   identifies stage two x-coordinates.  Note that x-coordinates are required
#'   for calculation of the local mean variance estimator.  The default value is
#'   NULL.
#'
#' @param ycoord Character value providing name of the y-coordinate variable in
#'   the dframe data frame.  For a two-stage sample, the y-coordinate variable
#'   identifies stage two y-coordinates.  Note that y-coordinates are required
#'   for calculation of the local mean variance estimator.  The default value is
#'   NULL.
#'
#' @param stratumID Character value providing name of the stratum ID variable in
#'   the dframe data frame.  The default value is NULL.
#'
#' @param clusterID Character value providing name of the cluster (stage one) ID
#'   variable in the dframe data frame.  Note that cluster IDs are required for
#'   a two-stage sample.  The default value is NULL.
#'
#' @param weight1 Character value providing name of the stage one weight
#'   variable in the dframe data frame.  The default value is NULL.
#'
#' @param xcoord1 Character value providing name of the stage one x-coordinate
#'   variable in the dframe data frame.  Note that x-coordinates are required
#'   for calculation of the local mean variance estimator.  The default value is
#'   NULL.
#'
#' @param ycoord1 Character value providing name of the stage one y-coordinate
#'   variable in the dframe data frame.  Note that y-coordinates are required
#'   for calculation of the local mean variance estimator.  The default value is
#'   NULL.
#'
#' @param sizeweight Logical value that indicates whether size weights should be
#'   used during estimation, where TRUE = use size weights and FALSE = do not
#'   use size weights. To employ size weights for a single-stage sample, a value
#'   must be supplied for argument weight.  To employ size weights for a
#'   two-stage sample, values must be supplied for arguments weight and weight1.
#'   The default value is FALSE.
#'
#' @param sweight Character value providing name of the size weight variable in
#'   the dframe data frame.  For a two-stage sample, the size weight variable
#'   identifies stage two size weights.  The default value is NULL.
#'
#' @param sweight1 Character value providing name of the stage one size weight
#'   variable in the dframe data frame.  The default value is NULL.
#'
#' @param popcorrect Logical value that indicates whether the finite population
#'   correction factor is used during variance estimation. To employ the
#'   correction factor for a single-stage sample, values must be supplied for
#'   argument fpcsize.  To employ the correction factor for a two-stage sample,
#'   values must be supplied for arguments Ncluster and stage1size.  The default
#'   value is FALSE.
#'
#' @param fpcsize Character value providing name of the variable in the dframe
#'   data frame that identifies size of the resource, which is required for
#'   calculation of the finite population correction factor for a single-stage
#'   sample.  The default value is NULL.
#'
#' @param Ncluster Character value providing name of the variable in the dframe
#'   data frame that identifies the number of clusters (stage one sampling
#'   units) in the resource, which is required for calculation of the finite
#'   population correction factor for a two-stage sample.  This argument is also
#'   required for a two-stage sample when the popsize argument is not equal to
#'   NULL and the vartype argument equals "Local".  The default value is NULL.
#'
#' @param stage1size Character value providing name of the variable in the
#'   dframe data frame that identifies cluster size, i.e. the number of the
#'   stage two sampling units in the resource for a cluster.  Note that cluster
#'   size is required for calculation of the finite population correction factor
#'   for a two-stage sample. The default value is NULL.
#'
#' @param popsize Object that provides values for the population argument of the
#'   calibrate or postStratify functions.  For the calibrate function, the object
#'   is a named list, where the names identify factor variables in the dframe
#'   data frame.  Each element of the list is a named vector containing the
#'   population total for each level of the associated factor variable.  For the
#'   postStratify function, the object is either a data frame, table, or xtabs
#'   object that provides the population total for all combinations of selected
#'   factor varaibles in the dframe data frame.  If a data frame is used for
#'   popsize, the variable containing population totals must be the last
#'   variable in the data frame.  If a table is used for popsize, the table must
#'   have named dimnames where the names identify factor variables in the dframe
#'   data frame.  If the popsize argument is equal to NULL, then neither
#'   calibration nor post-stratification is performed.  The default value is
#'   NULL.\cr\cr
#'   Example popsize for calibration:\cr
#'     popsize <- list(Ecoregion = c(East = 750,\cr
#'                                   Central = 500,\cr
#'                                   West = 250),\cr
#'                     Type = c(Streams = 1150,\cr
#'                              Rivers = 350))\cr
#'   Example popsize for post-stratification using a data frame:\cr
#'     popsize <- data.frame(
#'       Ecoregion = rep(c("East", "Central", "West"), rep(2, 3)),\cr
#'       Type = rep(c("Streams", "Rivers"), 3),\cr
#'       Total = c(575, 175, 400, 100, 175, 75))\cr
#'   Example popsize for post-stratification using a table:\cr575
#'     popsize <- with(MySurveyFrame, table(Ecoregion, Type))\cr
#'   Example popsize for post-stratification using an xtabs object:\cr
#'     popsize <- xtabs(~Ecoregion + Type, data = MySurveyFrame)\cr
#'
#' @param vartype  Character value identifying the choice for variance
#'   estimator, where "Local" = local mean estimator and "SRS" = simple random
#'   sampling estimator.  The default value is "Local".
#'
#' @param conf Numeric value providing the confidence level.  The default value
#'   is 95.
#'
#' @return A data frame of population estimates for all combinations of
#'   subpopulations, categories within each subpopulation, response variables,
#'   and categories within each response variable.  Estimates are provided for
#'   proportion and size of the population plus standard error, margin of error,
#'   and confidence interval estimates.
#'
#' @section Other Functions Required:
#'   \describe{
#'     \item{\code{\link{calibrate}}}{conduct calibration for survey data}
#'     \item{\code{\link{input_check}}}{check input values for errors,
#'       consistency, and compatibility with analytical functions}
#'     \item{\code{\link{postStratify}}}{conduct post-stratification for survey
#'       data}
#'     \item{\code{\link{relrisk_var}}}{calculate values required for estimating
#'       variance of the relative risk estimate}
#'     \item{\code{\link{svydesign}}}{specifies a complex survey design}
#'     \item{\code{\link{uniqueID}}}{creates unique site IDs by appending a
#'       unique number to each occurrence of a site ID}
#'     \item{\code{\link{vecprint}}}{takes an input vector and outputs a
#'       character string with line breaks inserted}
#'   }
#'
#' @author Tom Kincaid \email{Kincaid.Tom@epa.gov}
#'
#' @seealso
#'   \code{\link{calibrate}}
#'   \code{\link{postStratify}}
#'
#' @keywords survey univar
#'
#' @examples
#' dframe <- data.frame(
#'   siteID = paste0("Site", 1:100),
#'   wgt = runif(100, 10, 100),
#'   xcoord = runif(100),
#'   ycoord = runif(100),
#'   stratum = rep(c("Stratum1", "Stratum2"), 50),
#'   RespVar1=sample(c("Poor", "Good"), 100, replace=TRUE),
#'   RespVar2=sample(c("Poor", "Good"), 100, replace=TRUE),
#'   StressVar=sample(c("Poor", "Good"), 100, replace=TRUE),
#'   All_Sites = rep("All Sites", 100),
#'   Resource_Class=rep(c("Agr", "Forest"), c(55,45)))
#' myresponse <- c("RespVar1", "RespVar2")
#' mystressor <- c("StressVar")
#' mysubpops <- c("All_Sites", "Resource_Class")
#' relrisk_analysis(dframe, vars_response = myresponse,
#'   vars_stressor = mystressor, subpops = mysubpops, siteID = "siteID",
#'   weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
#'   stratumID = "stratum")
#'
#' @export
################################################################################

relrisk_analysis <- function(dframe, vars_response, vars_stressor,
  response_levels = rep(list(c("Poor","Good")), length(vars_response)),
  stressor_levels = rep(list(c("Poor","Good")), length(vars_stressor)),
  subpops = NULL, siteID = "siteID", weight = "weight", xcoord = NULL,
  ycoord = NULL, stratumID = NULL, clusterID = NULL, weight1 = NULL,
  xcoord1 = NULL, ycoord1 = NULL, sizeweight = FALSE, sweight = NULL,
  sweight1 = NULL, popcorrect = FALSE, fpcsize = NULL, Ncluster = NULL,
  stage1size = NULL, popsize = NULL, vartype = "Local", conf = 95) {

# Create a vector for error messages

  error.ind <- FALSE
  error.vec <- NULL

# Create a data frame for warning messages

  warn.ind <- FALSE
  warn.df <- NULL
  fname <- "relrisk_analysis"

# Ensure that the dframe argument was provided

  if(missing(dframe)) {
    stop("\nThe dframe argument must be provided.\n")
  }

# Ensure that unused levels are dropped from factor variables in the dframe data
# frame

  dframe <- droplevels(dframe)

# Ensure that the dframe data frame contains the site ID variable

  if(!(siteID %in% names(dframe))) {
    ind <- FALSE
    error.ind <- TRUE
    msg <- paste0("The name provided for the siteID argument, \"", siteID, "\", does not occur among \nthe names for the dframe data frame.\n")
    error.vec <- c(error.vec, msg)
  } else {
    ind <- TRUE
  }

# Check site IDs for repeat values and, as necessary, create unique site IDs and
# output a warning message

  if(ind) {
    dframe$siteID <- dframe[, siteID]
    temp <- with(dframe, sapply(split(siteID, siteID), length))
    if(any(temp > 1)) {
      warn.ind <- TRUE
      temp.str <- vecprint(names(temp)[temp > 1])
      warn <- paste("The following site ID values occur more than once among the values that were \ninput to the function:\n", temp.str)
      act <- "Unique site ID values were created.\n"
      warn.df <- rbind(warn.df, data.frame(func=I(fname), subpoptype=NA,
        subpop=NA, indicator=NA, stratum=NA, warning=I(warn), action=I(act)))
      dframe$siteID <- uniqueID(dframe$siteID)
    }
  }

# Ensure that the dframe data frame contains the survey weight variable

  if(!(weight %in% names(dframe))) {
    error.ind <- TRUE
    msg <- paste0("The name provided for the weight argument, \"", weight, "\", does not occur among \nthe names for the dframe data frame.\n")
    error.vec <- c(error.vec, msg)
  }

# Create a list containing names of survey design variables

  design_names <- list(
    siteID = siteID,
    weight = weight,
    xcoord = xcoord,
    ycoord = ycoord,
    stratumID = stratumID,
    clusterID = clusterID,
    weight1 = weight1,
    xcoord1 = xcoord1,
    ycoord1 = ycoord1,
    sweight = sweight,
    sweight1 = sweight1,
    fpcsize = fpcsize,
    Ncluster = Ncluster,
    stage1size = stage1size)

# Ensure that a value was provided for the vars_response (response variable
# names) argument

  if(missing(vars_response)) {
    error.ind <- TRUE
    msg <- "A value must be provided for the vars_response (response variable names) argument.\n"
    error.vec <- c(error.vec, msg)
  }

# Ensure that a value was provided for the vars_stressor (stressor variable
# names) argument

  if(missing(vars_stressor)) {
    error.ind <- TRUE
    msg <- "A value must be provided for the vars_stressor (stressor variable names) argument.\n"
    error.vec <- c(error.vec, msg)
  }

# If a value was not provided for the subpops (subpopulation names) argument,
# assign the value "All_Sites" to the subpops argument and create a factor
# named "All_Sites" in the dframe data frame that takes the value "All Sites"

  if(is.null(subpops)) {
    subpops <- "All_Sites"
    dframe$All_Sites <- "All Sites"
    dframe$All_Sites <- factor(dframe$All_Sites)
  }

# Check input arguments

  temp <- input_check(dframe, design_names, vars_response, NULL, vars_stressor,
    NULL, subpops, sizeweight, popcorrect, popsize, vartype, conf,
    error.ind = error.ind, error.vec = error.vec)
  dframe <- temp$dframe
  vars_response <- temp$vars_cat
  vars_stressor <- temp$vars_stressor
  subpops <- temp$subpops
  popsize <- temp$popsize
  vartype <- temp$vartype
  error.ind <- temp$error.ind
  error.vec <- temp$error.vec

# Check arguments response_levels and stressor_levels

  if(is.null(response_levels)) {
    error.ind <- TRUE
    msg <- "Argument response_levels must be provided.\n"
    error.vec <- c(error.vec, msg)
  } else {
    if(!is.list(response_levels)) {
      error.ind <- TRUE
      msg <- "Argument response_levels must be a list.\n"
      error.vec <- c(error.vec, msg)
    }
    if(length(response_levels) != length(vars_response)) {
      error.ind <- TRUE
      msg <- "Argument response_levels must be the same length as argument vars_response.\n"
      error.vec <- c(error.vec, msg)
    }
    if(any(sapply(response_levels, function(x) length(x) != 2))) {
      error.ind <- TRUE
      msg <- "Each element of argument response_levels must contain only two values.\n"
      error.vec <- c(error.vec, msg)
    }
    if(any(sapply(response_levels, function(x) !is.character(x)))) {
      error.ind <- TRUE
      msg <- "Each element of argument response_levels must contain character values.\n"
      error.vec <- c(error.vec, msg)
    }
    if(all(vars_response %in% names(dframe))) {
      tst <- logical(length(vars_response))
      for(i in 1:length(vars_response)) {
        if(!all(response_levels[[i]] %in% levels(dframe[, vars_response[i]])))
          tst[i] <- TRUE
      }
      if(any(tst)) {
        temp.str <- vecprint(vars_response[tst])
        error.ind <- TRUE
        msg <- paste0("\nCategory names for the following response variables do not match category names \nin the response_levels argument:\n", temp.str)
        error.vec <- c(error.vec, msg)
      }
    }
  }

  if(is.null(stressor_levels)) {
    error.ind <- TRUE
    msg <- "Argument stressor_levels must be provided.\n"
    error.vec <- c(error.vec, msg)
  } else {
    if(!is.list(stressor_levels)) {
      error.ind <- TRUE
      msg <- "Argument stressor_levels must be a list.\n"
      error.vec <- c(error.vec, msg)
    }
    if(length(stressor_levels) != length(vars_stressor)) {
      error.ind <- TRUE
      msg <- "Argument stressor_levels must be the same length as argument vars_stressor.\n"
      error.vec <- c(error.vec, msg)
    }
    if(any(sapply(stressor_levels, function(x) length(x) != 2))) {
      error.ind <- TRUE
      msg <- "Each element of argument stressor_levels must contain only two values.\n"
      error.vec <- c(error.vec, msg)
    }
    if(any(sapply(stressor_levels, function(x) !is.character(x)))) {
      error.ind <- TRUE
      msg <- "Each element of argument stressor_levels must contain character values.\n"
      error.vec <- c(error.vec, msg)
    }
    if(all(vars_stressor %in% names(dframe))) {
      tst <- logical(length(vars_stressor))
      for(i in 1:length(vars_stressor)) {
        if(!all(stressor_levels[[i]] %in% levels(dframe[, vars_stressor[i]])))
          tst[i] <- TRUE
      }
      if(any(tst)) {
        temp.str <- vecprint(vars_stressor[tst])
        error.ind <- TRUE
        msg <- paste0("\nCategory names for the following stressor variables do not match category names \nin the stressor_levels argument:\n", temp.str)
        error.vec <- c(error.vec, msg)
      }
    }
  }

# As nesessary, provide names for the response_levels and stressor_levels lists

  if(!is.null(response_levels)) {
    if(is.null(names(response_levels))) {
      names(response_levels) <- vars_response
    } else {
      if(!all(names(response_levels)) %in% vars_response) {
        error.ind <- TRUE
        msg <- "Names for the response_levels list do not match the values in the vars_response \nargument."
        error.vec <- c(error.vec, msg)
      }
    }
  }

  if(!is.null(stressor_levels)) {
    if(is.null(names(stressor_levels))) {
      names(stressor_levels) <- vars_stressor
    } else {
      if(!all(names(stressor_levels) %in% vars_stressor)) {
        error.ind <- TRUE
        msg <- "Names for the stressor_levels list do not match the values in the vars_stressor \nargument."
        error.vec <- c(error.vec, msg)
      }
    }
  }

# As necessary, output a message indicating that error messages were generated
# during execution of the program

  if(error.ind) {
    error.vec <<- error.vec
    if(length(error.vec) == 1) {
      cat("During execution of the program, an error message was generated.  The error \nmessage is stored in a vector named 'error.vec'.  Enter the following command \nto view the error message: errorprnt()\n")
    } else {
      cat(paste("During execution of the program,", length(error.vec), "error messages were generated.  The error \nmessages are stored in a vector named 'error.vec'.  Enter the following \ncommand to view the error messages: errorprnt()\n"))
    }

    if(warn.ind) {
      warn.df <<- warn.df
      if(nrow(warn.df) == 1) {
        cat("During execution of the program, a warning message was generated.  The warning \nmessage is stored in a data frame named 'warn.df'.  Enter the following command \nto view the warning message: warnprnt()\n")
      } else {
        cat(paste("During execution of the program,", nrow(warn.df), "warning messages were generated.  The warning \nmessages are stored in a data frame named 'warn.df'.  Enter the following \ncommand to view the warning messages: warnprnt() \nTo view a subset of the warning messages (say, messages number 1, 3, and 5), \nenter the following command: warnprnt(m=c(1,3,5))\n"))
      }
    }
    stop("See the preceding message(s).")
  }

# Assign a logical value to the indicator variable for a stratified sample

  stratum.ind <- !is.null(stratumID)

# For a stratified sample, remove strata that contain a single site

  if(stratum.ind) {
    dframe[, stratumID] <- factor(dframe[, stratumID])
    stratum.levels <- levels(dframe[, stratumID])
    nstrata <- length(stratum.levels)
    ind <- FALSE
    for(i in 1:nstrata) {
      tst <- dframe[, stratumID] == stratum.levels[i]
      if(sum(tst) == 1) {
        warn.ind <- TRUE
        warn <- paste("The stratum named \"", stratum.levels[i], "\" contains a single value and was removed from the analysis.\n")
        act <- "Stratum was removed from the analysis.\n"
        warn.df <- rbind(warn.df, data.frame(func=I(fname), subpoptype=NA,
          subpop=NA, indicator=NA, stratum=NA, warning=I(warn), action=I(act)))
        dframe <- dframe[!tst,]
        ind <- TRUE
      }
    }
    if(ind) {
      dframe[, stratumID] <- factor(dframe[, stratumID])
      stratum.levels <- levels(dframe[, stratumID])
      nstrata <- length(stratum.levels)
    }
  }

# Assign a logical value to the indicator variable for a two-stage sample

  cluster.ind <- !is.null(clusterID)

# Create the survey design object

  if(stratum.ind) {
    if(cluster.ind) {
      if(sizeweight) {
        dframe$wgt1 <- dframe[, weight1] * dframe[, sweight1]
        dframe$wgt2 <- dframe[, weight] * dframe[, sweight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            strata = make.formula(stratumID),
            nest = TRUE,
            fpc = make.formula(paste(Ncluster, stage1size, sep=" + ")),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            strata = make.formula(stratumID),
            nest = TRUE,
            data = dframe)
        }
      } else {
        dframe$wgt1 <- dframe[, weight1]
        dframe$wgt2 <- dframe[, weight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            strata = make.formula(stratumID),
            nest = TRUE,
            fpc = make.formula(paste(Ncluster, stage1size, sep=" + ")),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            strata = make.formula(stratumID),
            nest = TRUE,
            data = dframe)
        }
      }
    } else {
      if(sizeweight) {
        dframe$wgt <- dframe[, weight] * dframe[, sweight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            strata = make.formula(stratumID),
            fpc = make.formula(fpcsize),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            strata = make.formula(stratumID),
            data = dframe)
        }
      } else {
        dframe$wgt <- dframe[, weight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            strata = make.formula(stratumID),
            fpc = make.formula(fpcsize),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            strata = make.formula(stratumID),
            data = dframe)
        }
      }
    }
  } else {
    if(cluster.ind) {
      if(sizeweight) {
        dframe$wgt1 <- dframe[, weight1] * dframe[, sweight1]
        dframe$wgt2 <- dframe[, weight] * dframe[, sweight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            fpc = make.formula(paste(Ncluster, stage1size, sep=" + ")),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            data = dframe)
        }
      } else {
        dframe$wgt1 <- dframe[, weight1]
        dframe$wgt2 <- dframe[, weight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            fpc = make.formula(paste(Ncluster, stage1size, sep=" + ")),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            data = dframe)
        }
      }
    } else {
      if(sizeweight) {
        dframe$wgt <- dframe[, weight] * dframe[, sweight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            fpc = make.formula(fpcsize),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            data = dframe)
        }
      } else {
        dframe$wgt <- dframe[, weight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            fpc = make.formula(fpcsize),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            data = dframe)
        }
      }
    }
  }

# If popsize is not equal to NULL, then call either the postStratify or
# calibrate function, as appropriate

  if(!is.null(popsize)) {
    if(all(class(popsize) %in% c("data.frame", "table", "xtabs"))) {
      if("data.frame" %in% class(popsize)) {
        pnames <- names(popsize)[-ncol(popsize)]
      } else {
        pnames <- names(dimnames(popsize))
      }
      design <- postStratify(design, make.formula(pnames), popsize)
    } else {
      cnames <- cal_names(make.formula(names(popsize)), design)
      pop.totals <- numeric(length(cnames))
      names(pop.totals) <- cnames
      pop.totals[1] <-sum(popsize[[1]])
      k <- 2
      for(i in names(popsize)) {
        temp <- popsize[[i]]
        for(j in 2:length(temp)) {
          pop.totals[k] <-temp[j]
          k <- k+1
        }
      }
      design <- calibrate(design, make.formula(cnames), pop.totals)
    }
  }

# If popsize is not equal to NULL and vartype equals "Local", then assign
# adjusted weights to the appropriate weight variable(s) in the design$variables
# data frame

  if(!is.null(popsize) && vartype == "Local") {
    if(cluster.ind) {
      ncluster <- length(unique(design$variables[, clusterID]))
      design$variables$wgt1 <- unique(design$variables[, Ncluster]) / ncluster
      design$variables$wgt2 <- weights(design)/design$variables$wgt1
    } else {
      design$variables$wgt <- weights(design)
    }
    dframe <- design$variables
  }

# For variables that exist in the design$variables data frame, assign survey
# design variables

  for(i in names(design_names)) {
    if(is.null(design_names[[i]])) {
      eval(parse(text=paste0(i, " <- NULL")))
    } else {
      eval(parse(text=paste0(i, " <- dframe[, \"", design_names[[i]], "\"]")))
    }
  }

# Assign values to weight variables

  if(cluster.ind) {
    wgt1 <- dframe$wgt1
    wgt2 <- dframe$wgt2
  } else {
    wgt <- dframe$wgt
  }

# Create the rrsum (results) data frame

  rrsum <- NULL

# Assign the confidence bound multiplier

  mult  <- qnorm(0.5 + (conf/100)/2)

# Loop through all subpopulations (domains)

  for(itype in subpops) {

    lev_itype <- levels(dframe[, itype])
    nlev_itype <- length(lev_itype)

# Loop through all response variables (vars_response)

    for(ivar_r in vars_response) {

# Loop through all stressor variables (vars_stressor)

      for(ivar_s in vars_stressor) {

# Loop through all levels of the subpopulation

        for(isubpop in lev_itype) {

          tst <- !is.na(dframe[, itype]) & dframe[, itype] == isubpop &
            !is.na(dframe[, ivar_r]) & !is.na(dframe[, ivar_s])

# Assign response variable values

          response <- dframe[, ivar_r]
          nresp <- length(response)

# Assign stressor variable values

          stressor <- dframe[, ivar_s]

# Create the warn.vec object

          warn.vec <- c(itype, isubpop, paste(ivar_r, "and", ivar_s))

#
# Branch to handle stratified and unstratified data
#

          if(stratum.ind) {

#
# Begin the section for stratified data
#

# Initialize variables for all strata combined
            wgt.total <- 0
            varest <- 0

#
# Begin the subsection for individual strata
#

            for(i in 1:nstrata) {

# Calculate required values

              stratum.i <- tst & stratumID == stratum.levels[i]
              response.st <- response[stratum.i]
              stressor.st <- stressor[stratum.i]
              if(cluster.ind) {
                wgt1.st <- wgt1[stratum.i]
                wgt2.st <- wgt2[stratum.i]
              } else {
                wgt.st <- wgt[stratum.i]
              }

# Compute the 2x2 table of weight totals

              wgt.total.st <- svytable(make.formula(paste(ivar_r, "+",
              ivar_s)), design = subset(design, stratum.i))

# Calculate the variance-covariance estimate for the cell and marginal totals

              if(cluster.ind) {
                temp <- relrisk_var(response[stratum.i], stressor[stratum.i],
                  response_levels[[ivar_r]], stressor_levels[[ivar_s]],
                  wgt2[stratum.i], xcoord[stratum.i], ycoord[stratum.i],
                  stratum.ind, stratum.levels[i], cluster.ind,
                  clusterID[stratum.i], wgt1[stratum.i], xcoord1[stratum.i],
                  ycoord1[stratum.i], popcorrect, NULL, Ncluster[stratum.i],
                  stage1size[stratum.i], vartype, warn.ind, warn.df, warn.vec)
              } else {
                temp <- relrisk_var(response[stratum.i], stressor[stratum.i],
                  response_levels[[ivar_r]], stressor_levels[[ivar_s]],
                  wgt[stratum.i], xcoord[stratum.i], ycoord[stratum.i],
                  stratum.ind, stratum.levels[i], cluster.ind,
                  pcfactor.ind = popcorrect, fpcsize = fpcsize[stratum.i],
                  vartype = vartype, warn.ind = warn.ind, warn.df = warn.df,
                  warn.vec = warn.vec)
              }
              varest.st <- temp$varest
              warn.ind <- temp$warn.ind
              warn.df <- temp$warn.df

# Add estimates to the variables for all strata combined

              wgt.total <- wgt.total + wgt.total.st
              varest <- varest + varest.st

#
# End the subsection for individual strata
#

            }

# Add margins to the wgt.total table

            wgt.total <- addmargins(wgt.total)

# Assign cell and marginal weight totals

            total1 <- wgt.total[response_levels[[ivar_r]][1],
              stressor_levels[[ivar_s]][1]]
            total2 <- wgt.total["Sum", stressor_levels[[ivar_s]][1]]
            total3 <- wgt.total[response_levels[[ivar_r]][1],
              stressor_levels[[ivar_s]][2]]
            total4 <- wgt.total["Sum", stressor_levels[[ivar_s]][2]]

# Calculate the estimate of relative risk for all strata combined

            if(total2 == 0 || total4 == 0) {
              rr <- NA
              rr.num <- NA
              rr.denom <- NA
              warn.ind <- TRUE
              temp <- ifelse(total2 == 0, stressor_levels[[ivar_s]][1],
                stressor_levels[[ivar_s]][2])
              warn <- paste0("Since there are no observations for level \"", temp, "\" of the stressor \nvariable, the relative risk estimate and its standard error cannot be \ncalculated for stratum \"", stratum.levels[i], "\".  Also, the stratum \nwas removed from the analysis.\n")
              act <- paste0("The relative risk estimate and its standard error were not calculated for \nstratum \"", stratum.levels[i], "\".  Also, the stratum was removed from \nthe analysis.\n")
              warn.df <- rbind(warn.df, data.frame(func=I(fname),
                subpoptype=warn.vec[1], subpop=warn.vec[2],
                indicator=warn.vec[3], stratum=NA, warning=I(warn),
                action=I(act)))
            } else if(total1 == 0 && total3 != 0) {
              rr <- 0
              rr.num <- 0
              rr.denom <- total3/total4
              warn.ind <- TRUE
              warn <- paste0("Since there are no observations for the cell defined by level \"", response_levels[[ivar_r]][1], "\" \nof the response variable and level \"", stressor_levels[[ivar_s]][1], "\" of the stressor \nvariable, the relative risk estimate is zero and standard error of the relative \nrisk estimate cannot be calculated for stratum \"", stratum.levels[i], "\".  \nAlso, the stratum was removed from the analysis.\n")
              act <- paste0("Standard error of the relative risk estimate was not calculated for stratum \n\"", stratum.levels[i], "\".  Also, the stratum was removed from the \nanalysis.\n")
              warn.df <- rbind(warn.df, data.frame(func=I(fname),
                subpoptype=warn.vec[1], subpop=warn.vec[2],
                indicator=warn.vec[3], stratum=NA, warning=I(warn),
                action=I(act)))
            } else if(total1 == 0 && total3 == 0) {
              rr <- NA
              rr.num <- total1/total2
              rr.denom <- total3/total4
              warn.ind <- TRUE
              warn <- paste0("Since there are no observations for the cell defined by level \"", response_levels[[ivar_r]][1], "\" \nof the response variable and level \"", stressor_levels[[ivar_s]][1], "\" of the stressor \nvariable and for the cell defined by level \"", response_levels[[ivar_r]][1], "\" of the \nresponse variable and level \"", stressor_levels[[ivar_s]][2], "\" of the stressor variable, \nthe relative risk estimate and its standard error cannot be calculated for \nstratum \"", stratum.levels[i], "\".  Also, the stratum was removed from \nthe analysis.\n")
              act <- paste0("The relative risk estimate and its standard error were not calculated for \nstratum \"", stratum.levels[i], "\".  Also, the stratum was removed from \nthe analysis.\n")
              warn.df <- rbind(warn.df, data.frame(func=I(fname),
                subpoptype=warn.vec[1], subpop=warn.vec[2],
                indicator=warn.vec[3], stratum=NA, warning=I(warn),
                action=I(act)))
            } else if(total3 == 0) {
              rr <- NA
              rr.num <- total1/total2
              rr.denom <- total3/total4
              warn.ind <- TRUE
              warn <- paste0("Since there are no observations for the cell defined by level \"", response_levels[[ivar_r]][1], "\" \nof the response variable and level \"", stressor_levels[[ivar_s]][2], "\" of the stressor \nvariable, the relative risk estimate and its standard error cannot be \ncalculated for stratum \"", stratum.levels[i], "\".  Also, the stratum \nwas removed from the analysis.\n")
              act <- paste0("The relative risk estimate and its standard error were not calculated for \nstratum \"", stratum.levels[i], "\".  Also, the stratum was removed from \nthe analysis.\n")
              warn.df <- rbind(warn.df, data.frame(func=I(fname),
                subpoptype=warn.vec[1], subpop=warn.vec[2],
                indicator=warn.vec[3], stratum=NA, warning=I(warn),
                action=I(act)))
            } else {
              rr <- (total1*total4) / (total2*total3)
              rr.num <- total1/total2
              rr.denom <- total3/total4
            }

# Calculate the standard error estimate of the log of relative risk for all
# strata combined

            if(any(c(total1, total2, total3, total4) == 0)) {
              rrlog.se <- NA
            } else {
              pder <- 1/c(total1, -total2, -total3, total4)
              rrlog.se <- sqrt(t(pder) %*% varest %*% pder)
            }

#
# End the section for stratified data
#

          } else {

#
# Begin the section for unstratified data
#

# Check whether the vector of response values contains a single element
            if(nresp == 1)
              stop("\nEstimates cannot be calculated since the vector of response values contains a \nsingle element.")

# Compute the 2x2 table of weight totals

            wgt.total <- addmargins(svytable(make.formula(paste(ivar_r, "+",
              ivar_s)), design = subset(design, tst)))

# Assign cell and marginal weight totals

            total1 <- wgt.total[response_levels[[ivar_r]][1],
              stressor_levels[[ivar_s]][1]]
            total2 <- wgt.total["Sum", stressor_levels[[ivar_s]][1]]
            total3 <- wgt.total[response_levels[[ivar_r]][1],
              stressor_levels[[ivar_s]][2]]
            total4 <- wgt.total["Sum", stressor_levels[[ivar_s]][2]]

# Calculate the estimate of relative risk

            if(total2 == 0 || total4 == 0) {
              rr <- NA
              rr.num <- NA
              rr.denom <- NA
              warn.ind <- TRUE
              temp <- ifelse(total2 == 0, stressor_levels[[ivar_s]][1],
                stressor_levels[[ivar_s]][2])
              warn <- paste0("Since there are no observations for level \"", temp, "\" of the stressor \nvariable, the relative risk estimate and its standard error cannot be \ncalculated.\n")
              act <- "The relative risk estimate and its standard error were not calculated.\n"
              warn.df <- rbind(warn.df, data.frame(func=I(fname),
                subpoptype=warn.vec[1], subpop=warn.vec[2],
                indicator=warn.vec[3], stratum=NA, warning=I(warn),
                action=I(act)))
            } else if(total1 == 0 && total3 != 0) {
              rr <- 0
              rr.num <- 0
              rr.denom <- total3/total4
              warn.ind <- TRUE
              warn <- paste0("Since there are no observations for the cell defined by level \"", response_levels[[ivar_r]][1], "\" \nof the response variable and level \"", stressor_levels[[ivar_s]][1], "\" of the stressor variable, \nthe relative risk estimate is zero and standard error of the relative risk \nestimate cannot be calculated.\n")
              act <- "Standard error of the relative risk estimate was not calculated.\n"
              warn.df <- rbind(warn.df, data.frame(func=I(fname),
                subpoptype=warn.vec[1], subpop=warn.vec[2],
                indicator=warn.vec[3], stratum=NA, warning=I(warn),
                action=I(act)))
            } else if(total1 == 0 && total3 == 0) {
              rr <- NA
              rr.num <- total1/total2
              rr.denom <- total3/total4
              warn.ind <- TRUE
              warn <- paste0("Since there are no observations for the cell defined by level \"", response_levels[[ivar_r]][1], "\" \nof the response variable and level \"", stressor_levels[[ivar_s]][1], "\" of the stressor \nvariable and for the cell defined by level \"", response_levels[[ivar_r]][1], "\" of the \nresponse variable and level \"", stressor_levels[[ivar_s]][2], "\" of the stressor variable, \nthe relative risk estimate and its standard error cannot be calculated.\n")
              act <- "The relative risk estimate and its standard error were not calculated.\n"
              warn.df <- rbind(warn.df, data.frame(func=I(fname),
                subpoptype=warn.vec[1], subpop=warn.vec[2],
                indicator=warn.vec[3], stratum=NA, warning=I(warn),
                action=I(act)))
            } else if(total3 == 0) {
              rr <- NA
              rr.num <- total1/total2
                       rr.denom <- total3/total4
              warn.ind <- TRUE
              warn <- paste0("Since there are no observations for the cell defined by level \"", response_levels[[ivar_r]][1], "\" \nof the response variable and level \"", stressor_levels[[ivar_s]][2], "\" of the stressor \nvariable, the relative risk estimate and its standard error cannot be \ncalculated.\n")
              act <- "The relative risk estimate and its standard error were not calculated.\n"
              warn.df <- rbind(warn.df, data.frame(func=I(fname),
                subpoptype=warn.vec[1], subpop=warn.vec[2],
                indicator=warn.vec[3], stratum=NA, warning=I(warn),
                action=I(act)))
            } else {
              rr <- (total1*total4) / (total2*total3)
              rr.num <- total1/total2
              rr.denom <- total3/total4
            }

# Determine whether the standard error can be calculated

            if(any(c(total1, total2, total3, total4) == 0)) {
              rrlog.se <- NA
            } else {

# Calculate the variance-covariance estimate for the cell and marginal totals

              if(cluster.ind) {
                temp <- relrisk_var(response[tst], stressor[tst],
                  response_levels[[ivar_r]], stressor_levels[[ivar_s]],
                  wgt2[tst], xcoord[tst], ycoord[tst], stratum.ind, NULL,
                  cluster.ind, clusterID[tst], wgt1[tst], xcoord1[tst],
                  ycoord1[tst], popcorrect, NULL, Ncluster[tst],
                  stage1size[tst], vartype, warn.ind, warn.df, warn.vec)
              } else {
                temp <- relrisk_var(response[tst], stressor[tst],
                  response_levels[[ivar_r]], stressor_levels[[ivar_s]],
                  wgt[tst], xcoord[tst], ycoord[tst], stratum.ind, NULL,
                  cluster.ind, pcfactor.ind = popcorrect,
                  fpcsize = fpcsize[tst], vartype = vartype,
                 warn.ind = warn.ind, warn.df = warn.df,
                  warn.vec = warn.vec)
              }
              varest <- temp$varest
              warn.ind <- temp$warn.ind
              warn.df <- temp$warn.df

# Calculate the standard error estimate of the log of relative risk

              pder <- 1/c(total1, -total2, -total3, total4)
              rrlog.se <- sqrt(t(pder) %*% varest %*% pder)
            }

#
# End section for unstratified data
#

          }

# Calculate confidence limits for the estimate of relative risk

          if(is.na(rrlog.se)) {
            cl <- NA
          } else {
            cl <- c(exp(log(rr) - rrlog.se * mult), exp(log(rr) + rrlog.se *
              mult))
          }

# Calculate the table of cell and margin counts

          cc <- addmargins(table(list(response = response[tst],
            stressor = stressor[tst])))

# Calculate the table of cell and margin proportion estimates

          cp <- wgt.total / wgt.total["Sum", "Sum"]

# Append results to the rrsum data frame

          rrsum <- rbind(rrsum, data.frame(
            Type = itype,
            Subpopulation = isubpop,
            Response = ivar_r,
            Stressor = ivar_s,
            nResp = cc[3, 3],
            Estimate = rr,
            Estimate.num = rr.num,
            Estimate.denom = rr.denom,
            StdError.log = rrlog.se,
            MarginofError.log = mult * rrlog.se,
            LCB = cl[1],
            UCB = cl[2],
            WeightTotal = wgt.total["Sum", "Sum"],
            CellCounts.11 = cc[response_levels[[ivar_r]][1],
              stressor_levels[[ivar_s]][1]],
            CellCounts.12 = cc[response_levels[[ivar_r]][1],
              stressor_levels[[ivar_s]][2]],
            CellCounts.21 = cc[response_levels[[ivar_r]][2],
              stressor_levels[[ivar_s]][1]],
            CellCounts.22 = cc[response_levels[[ivar_r]][2],
              stressor_levels[[ivar_s]][2]],
            CellProportions.11 = cp[response_levels[[ivar_r]][1],
              stressor_levels[[ivar_s]][1]],
            CellProportions.12 = cp[response_levels[[ivar_r]][1],
              stressor_levels[[ivar_s]][2]],
            CellProportions.21 = cp[response_levels[[ivar_r]][2],
              stressor_levels[[ivar_s]][1]],
            CellProportions.22 = cp[response_levels[[ivar_r]][2],
              stressor_levels[[ivar_s]][2]]))

# End of the loop for levels of the subpopulation

        }

# End of the loop for stressor variables

      }

# End of the loop for response variables

    }

# End of the loop for subpopulations

  }

# As necessary, output a message indicating that warning messages were generated
# during execution of the program

  if(warn.ind) {
    warn.df <<- warn.df
    if(nrow(warn.df) == 1) {
      cat("During execution of the program, a warning message was generated.  The warning \nmessage is stored in a data frame named 'warn.df'.  Enter the following command \nto view the warning message: warnprnt()\n")
    } else {
      cat(paste("During execution of the program,", nrow(warn.df), "warning messages were generated.  The warning \nmessages are stored in a data frame named 'warn.df'.  Enter the following \ncommand to view the warning messages: warnprnt() \nTo view a subset of the warning messages (say, messages number 1, 3, and 5), \nenter the following command: warnprnt(m=c(1,3,5))\n"))
    }
  }

# Assign dimension names to the rrsum data frame

  dimnames(rrsum) <- list(1:nrow(rrsum), c("Type", "Subpopulation", "Response",
    "Stressor", "nResp", "Estimate", "Estimate.num", "Estimate.denom",
    "StdError.log", "MarginofError.log", paste0("LCB", conf, "Pct"),
    paste0("UCB", conf, "Pct"), "WeightTotal", "CellCounts.11", "CellCounts.12",
    "CellCounts.21", "CellCounts.22", "CellProportions.11",
    "CellProportions.12", "CellProportions.21", "CellProportions.22"))

# Return the rrsum data frame

  rrsum
}
