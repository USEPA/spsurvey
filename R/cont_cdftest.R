################################################################################
# Function: cont_cdftest
# Programmer Tom Kincaid
# Date: October 23, 2020
#'
#' Cumulative Distribution Function Inference for a Probability Survey
#'
#' This function organizes input and output for conducting inference regarding
#' cumulative distribution functions (CDFs) generated by a probability survey.
#' For every response variable and every subpopulation (domain) variable,
#' differences between CDFs are tested for every pair of subpopulations within
#' the domain.  Data input to the function can be either a single surey or
#' multiple surveys (two or more).  If the data contain multile surveys, then
#' the domain variables will reference those surveys and (potentially)
#' subpopulations within those surveys.  The inferential procedures divide the
#' CDFs into a discrete set of intervals (classes) and then utilize procedures
#' that have been developed for analysis of categorical data from probability
#' surveys.  Choices for inference are the Wald, adjusted Wald, Rao-Scott first
#' order corrected (mean eigenvalue corrected), and Rao-Scott second order
#' corrected (Satterthwaite corrected) test statistics. The default test
#' statistic is the adjusted Wald statistic.  The input data argument can be
#' either a data frame or a simple features (sf) object.  If an sf object is
#' used, coordinates are extracted from the geometry column in the object,
#' arguments xcoord and ycoord are assigned values "xcoord" and "ycoord",
#' respectively, and the geometry column is dropped from the object.
#'
#' @param dframe Data frame containing survey design variables, response
#'   variables, and subpopulation (domain) variables.
#'
#' @param vars Vector composed of character values that identify the
#'   names of response variables in the dframe data frame.
#'
#' @param subpops Vector composed of character values that identify the
#'   names of subpopulation (domain) variables in the dframe data frame.  If a
#'   value is not provided, the value "All_Sites" is assigned to the subpops
#'   argument and a factor variable named "All_Sites" that takes the value
#'   "All Sites" is added to the dframe data frame.  The default value is NULL.
#'
#' @param surveyID Character value providing name of the survey ID variable in
#'   the dframe data frame.  If this argument equals NULL, then the dframe data
#'   frame contains data for a single survey.  The default value is NULL.
#'
#' @param siteID Character value providing name of the site ID variable in
#'   the dframe data frame.  For a two-stage sample, the site ID variable
#'   identifies stage two site IDs.  The default value is "siteID".
#'
#' @param weight Character value providing name of the survey design weight
#'   variable in the dframe data frame.  For a two-stage sample, the weight
#'   variable identifies stage two weights.  The default value is "weight".
#'
#' @param xcoord Character value providing name of the x-coordinate variable in
#'   the dframe data frame.  For a two-stage sample, the x-coordinate variable
#'   identifies stage two x-coordinates.  Note that x-coordinates are required
#'   for calculation of the local mean variance estimator.  The default value is
#'   NULL.
#'
#' @param ycoord Character value providing name of the y-coordinate variable in
#'   the dframe data frame.  For a two-stage sample, the y-coordinate variable
#'   identifies stage two y-coordinates.  Note that y-coordinates are required
#'   for calculation of the local mean variance estimator.  The default value is
#'   NULL.
#'
#' @param stratumID Character value providing name of the stratum ID variable in
#'   the dframe data frame.  The default value is NULL.
#'
#' @param clusterID Character value providing name of the cluster (stage one) ID
#'   variable in the dframe data frame.  Note that cluster IDs are required for
#'   a two-stage sample.  The default value is NULL.
#'
#' @param weight1 Character value providing name of the stage one weight
#'   variable in the dframe data frame.  The default value is NULL.
#'
#' @param xcoord1 Character value providing name of the stage one x-coordinate
#'   variable in the dframe data frame.  Note that x-coordinates are required
#'   for calculation of the local mean variance estimator.  The default value is
#'   NULL.
#'
#' @param ycoord1 Character value providing name of the stage one y-coordinate
#'   variable in the dframe data frame.  Note that y-coordinates are required
#'   for calculation of the local mean variance estimator.  The default value is
#'   NULL.
#'
#' @param sizeweight Logical value that indicates whether size weights should be
#'   used during estimation, where TRUE = use size weights and FALSE = do not
#'   use size weights. To employ size weights for a single-stage sample, a value
#'   must be supplied for argument weight.  To employ size weights for a
#'   two-stage sample, values must be supplied for arguments weight and weight1.
#'   The default value is FALSE.
#'
#' @param sweight Character value providing name of the size weight variable in
#'   the dframe data frame.  For a two-stage sample, the size weight variable
#'   identifies stage two size weights.  The default value is NULL.
#'
#' @param sweight1 Character value providing name of the stage one size weight
#'   variable in the dframe data frame.  The default value is NULL.
#'
#' @param popcorrect Logical value that indicates whether the finite population
#'   correction factor is used during variance estimation. To employ the
#'   correction factor for a single-stage sample, values must be supplied for
#'   argument fpcsize.  To employ the correction factor for a two-stage sample,
#'   values must be supplied for arguments Ncluster and stage1size.  The default
#'   value is FALSE.
#'
#' @param fpcsize Character value providing name of the variable in the dframe
#'   data frame that identifies size of the resource, which is required for
#'   calculation of the finite population correction factor for a single-stage
#'   sample.  The default value is NULL.
#'
#' @param Ncluster Character value providing name of the variable in the dframe
#'   data frame that identifies the number of clusters (stage one sampling
#'   units) in the resource, which is required for calculation of the finite
#'   population correction factor for a two-stage sample.  This argument is also
#'   required for a two-stage sample when the popsize argument is not equal to
#'   NULL and the vartype argument equals "Local".  The default value is NULL.
#'
#' @param stage1size Character value providing name of the variable in the
#'   dframe data frame that identifies cluster size, i.e. the number of the
#'   stage two sampling units in the resource for a cluster.  Note that cluster
#'   size is required for calculation of the finite population correction factor
#'   for a two-stage sample. The default value is NULL.
#'
#' @param popsize Object that provides values for the population argument of the
#'   calibrate or postStratify functions.  For the calibrate function, the object
#'   is a named list, where the names identify factor variables in the dframe
#'   data frame.  Each element of the list is a named vector containing the
#'   population total for each level of the associated factor variable.  For the
#'   postStratify function, the object is either a data frame, table, or xtabs
#'   object that provides the population total for all combinations of selected
#'   factor variables in the dframe data frame.  If a data frame is used for
#'   popsize, the variable containing population totals must be the last
#'   variable in the data frame.  If a table is used for popsize, the table must
#'   have named dimnames where the names identify factor variables in the dframe
#'   data frame.  If the popsize argument is equal to NULL, then neither
#'   calibration nor post-stratification is performed.  The default value is
#'   NULL.\cr\cr
#'   Example popsize for calibration:\cr
#'     popsize <- list(Ecoregion = c(East = 750,\cr
#'                                   Central = 500,\cr
#'                                   West = 250),\cr
#'                     Type = c(Streams = 1150,\cr
#'                              Rivers = 350))\cr
#'   Example popsize for post-stratification using a data frame:\cr
#'     popsize <- data.frame(
#'       Ecoregion = rep(c("East", "Central", "West"), rep(2, 3)),\cr
#'       Type = rep(c("Streams", "Rivers"), 3),\cr
#'       Total = c(575, 175, 400, 100, 175, 75))\cr
#'   Example popsize for post-stratification using a table:\cr575
#'     popsize <- with(MySurveyFrame, table(Ecoregion, Type))\cr
#'   Example popsize for post-stratification using an xtabs object:\cr
#'     popsize <- xtabs(~Ecoregion + Type, data = MySurveyFrame)\cr
#'
#' @param vartype  Character value identifying the choice for variance
#'   estimator, where "Local" = local mean estimator and "SRS" = simple random
#'   sampling estimator.  The default value is "Local".
#'
#' @param testname Name of the test statistic to be reported in the output
#'   data frame.  Choices for the name are: "Wald", "adjWald", "RaoScott_First",
#'   and "RaoScott_Second", which correspond to the Wald statistic, adjusted
#'   Wald statistic, Rao-Scott first-order corrected statistic, and Rao-Scott
#'   second-order corrected statistic, respectively.  The default is "adjWald".
#'
#' @param nclass Number of classes into which the CDFs will be divided
#'   (binned), which must equal at least two.  The default is 3.
#'
#' @return Data frame of CDF test results for all pairs of subpopulations
#'   within each population Type for every response variable.  The data frame
#'   includes the test statistic specified by argument testname plus its degrees
#'   of freedom and p-value.
#'
#' @section Other Functions Required:
#'   \describe{
#'     \item{\code{\link{calibrate}}}{conduct calibration for survey data}
#'     \item{\code{\link{cdftest_localmean_prop}}}{calculates local mean
#'       variance/covarince estimates of estimated population proportions}
#'     \item{\code{\link{cdftest_localmean_total}}}{calculates local mean
#'       variance/covarince estimates of estimated population totals}
#'     \item{\code{\link{input_check}}}{check input values for errors,
#'       consistency, and compatibility with analytical functions}
#'     \item{\code{\link{postStratify}}}{conduct post-stratification for survey
#'       data}
#'     \item{\code{\link{svychisq_localmean}}}{performs design-based contingency
#'       table tests}
#'     \item{\code{\link{svydesign}}}{specifies a complex survey design}
#'     \item{\code{\link{uniqueID}}}{creates unique site IDs by appending a
#'       unique number to each occurrence of a site ID}
#'     \item{\code{\link{vecprint}}}{takes an input vector and outputs a
#'       character string with line breaks inserted}
#'   }
#'
#' @author Tom Kincaid \email{Kincaid.Tom@epa.gov}
#'
#' @keywords survey
#'
#' @examples
#' n <- 200
#' mysiteID <- paste("Site", 1:n, sep="")
#' dframe <- data.frame(
#'   siteID = mysiteID,
#'   wgt = runif(n, 10, 100),
#'   xcoord = runif(n),
#'   ycoord = runif(n),
#'   stratum = rep(c("Stratum1", "Stratum2"), n/2),
#'   Resource_Class = sample(c("Agr", "Forest", "Urban"), n, replace=TRUE))
#' ContVar <- numeric(n)
#' tst <- dframe$Resource_Class == "Agr"
#' ContVar[tst] <- rnorm(sum(tst), 10, 1)
#' tst <- dframe$Resource_Class == "Forest"
#' ContVar[tst] <- rnorm(sum(tst), 10.1, 1)
#' tst <- dframe$Resource_Class == "Urban"
#' ContVar[tst] <- rnorm(sum(tst), 10.5, 1)
#' dframe$ContVar <- ContVar
#' myvars <- c("ContVar")
#' mysubpops <- c("Resource_Class")
#' mypopsize <- data.frame(
#'   Resource_Class = rep(c("Agr", "Forest", "Urban"), rep(2, 3)),
#'   stratum = rep(c("Stratum1", "Stratum2"), 3),
#'   Total = c(2500, 1500, 1000, 500, 600, 450))
#' cont_cdftest(dframe, vars = myvars, subpops = mysubpops, siteID = "siteID",
#'   weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
#'   stratumID = "stratum", popsize = mypopsize, testname="RaoScott_First")
#'
#' @export
################################################################################

cont_cdftest <- function(dframe, vars, subpops = NULL, surveyID = NULL,
  siteID = "siteID", weight = "weight", xcoord = NULL, ycoord = NULL,
  stratumID = NULL, clusterID = NULL, weight1 = NULL, xcoord1 = NULL,
  ycoord1 = NULL, sizeweight = FALSE, sweight = NULL, sweight1 = NULL,
  popcorrect = FALSE, fpcsize = NULL, Ncluster = NULL, stage1size = NULL,
  popsize = NULL, vartype = "Local", testname = "adjWald", nclass = 3) {

# Create a vector for error messages

  error.ind <- FALSE
  error.vec <- NULL

# Create a data frame for warning messages

  warn.ind <- FALSE
  warn.df <- NULL
  fname <- "cont_cdftest"

# Check for a valid test statistic name

  temp <- match(testname, c("Wald", "adjWald", "RaoScott_First",
    "RaoScott_Second"), nomatch=0)
  if(temp == 0) {
    error.ind <- TRUE
    msg <- paste0("\nThe value provided for argument testname, \"", testname, "\", is not a valid test statistic name.\n")
    error.vec <- c(error.vec, msg)
  }

# As necessary, reassign the test statistic name to match the values required
# by the svychisq_localmean function

  if(testname == "RaoScott_First") {
    testname <- "Chisq"
  } else if(testname == "RaoScott_Second") {
    testname <- "F"
  }

# Check for the minimum number of classes

  if(testname %in% c("Wald", "adjWald")) {
    if(nclass < 2) {
      error.ind <- TRUE
      msg <- paste("\nThe number of classes into which the CDFs will be divided (binned) must equal \nat least two.")
      error.vec <- c(error.vec, msg)
    }
  } else {
    if(nclass < 3) {
      error.ind <- TRUE
      msg <- paste("\nThe number of classes into which the CDFs will be divided (binned) must equal \nat least three")
      error.vec <- c(error.vec, msg)
    }
  }

# Ensure that the dframe argument was provided

  if(missing(dframe) | is.null(dframe)) {
    stop("\nThe dframe argument must be provided.\n")
  }

# If the dframe argument is an sf object, extract coordinates from the geometry
# column, assign values "xcoord" and "ycoord" to arguments xcoord and ycoord,
# respectively, and drop the geometry column from the object

  if("sf" %in% class(dframe)) {
    temp <- st_coordinates(dframe)
    xcoord <- "xcoord"
    dframe$xcoord <- temp[, "X"]
    ycoord <- "ycoord"
    dframe$ycoord <- temp[, "Y"]
    dframe <- st_set_geometry(dframe, NULL)
  }

# Ensure that unused levels are dropped from factor variables in the dframe data
# frame

  dframe <- droplevels(dframe)

# As necessary, ensure that the dframe data frame contains the survey ID
# variable

  if(!is.null(surveyID)) {
    if(!(surveyID %in% names(dframe))) {
      ind1 <- FALSE
      error.ind <- TRUE
      msg <- paste0("The name provided for the surveyID argument, \"", surveyID, "\", does not occur among \nthe names for the dframe data frame.\n")
      error.vec <- c(error.vec, msg)
    } else {
      survey_names <- as.vector(unique(dframe[, surveyID]))
      ind1 <- TRUE
    }
  }

# Ensure that the dframe data frame contains the site ID variable

  if(!(siteID %in% names(dframe))) {
    ind2 <- FALSE
    error.ind <- TRUE
    msg <- paste0("The name provided for the siteID argument, \"", siteID, "\", does not occur among \nthe names for the dframe data frame.\n")
    error.vec <- c(error.vec, msg)
  } else {
    ind2 <- TRUE
  }

# Check site IDs for repeat values and, as necessary, create unique site IDs and
# output a warning message

  if(is.null(surveyID)) {
    if(ind2) {
      dframe$siteID <- dframe[, siteID]
      temp <- with(dframe, sapply(split(siteID, siteID), length))
      if(any(temp > 1)) {
        warn.ind <- TRUE
        temp.str <- vecprint(names(temp)[temp > 1])
        warn <- paste("The following site ID values occur more than once among the values that were \ninput to the function:\n", temp.str)
        act <- "Unique site ID values were created.\n"
        warn.df <- rbind(warn.df, data.frame(func=I(fname), subpoptype=NA,
          subpop=NA, indicator=NA, stratum=NA, warning=I(warn), action=I(act)))
        dframe$siteID <- uniqueID(dframe$siteID)
      }
    }
  } else {
    if(ind1 & ind2) {
      dframe$surveyID <- dframe[, surveyID]
      dframe$siteID <- dframe[, siteID]
      for(i in survey_names) {
        eval(parse(text=paste0("tst <- dframe$surveyID == \"", i, "\"")))
        temp <- with(subset(dframe, tst), sapply(split(siteID, siteID), length))
        if(any(temp > 1)) {
          warn.ind <- TRUE
          temp.str <- vecprint(names(temp)[temp > 1])
          warn <- paste("The following site ID values occur more than once among survey", i, "values \nthat were input to the function:\n", temp.str)
          act <- "Unique site ID values were created.\n"
          warn.df <- rbind(warn.df, data.frame(func=I(fname), subpoptype=NA,
            subpop=NA, indicator=NA, stratum=NA, warning=I(warn), action=I(act)))
          dframe$siteID[tst] <- uniqueID(dframe$siteID[tst])
        }
      }
    }
  }

# Ensure that the dframe data frame contains the survey weight variable

  if(!(weight %in% names(dframe))) {
    error.ind <- TRUE
    msg <- paste0("The name provided for the weight argument, \"", weight, "\", does not occur among \nthe names for the dframe data frame.\n")
    error.vec <- c(error.vec, msg)
  }

# As necessary, create a stratum variable that incorporates survey ID values

  if(!is.null(surveyID)) {
    if(!is.null(stratumID)) {
      dframe$stratumID <- paste(dframe[, surveyID], dframe[, stratumID],
        sep=".")
      stratumID <- "stratumID"
    } else {
      stratumID <- surveyID
    }
  }

# Create a list containing names of survey design variables

  design_names <- list(
    siteID = siteID,
    weight = weight,
    xcoord = xcoord,
    ycoord = ycoord,
    stratumID = stratumID,
    clusterID = clusterID,
    weight1 = weight1,
    xcoord1 = xcoord1,
    ycoord1 = ycoord1,
    sweight = sweight,
    sweight1 = sweight1,
    fpcsize = fpcsize,
    Ncluster = Ncluster,
    stage1size = stage1size)

# Ensure that a value was provided for the vars (response variable names)
# argument

  if(is.null(vars)) {
    error.ind <- TRUE
    msg <- "A value must be provided for the vars (response variable names) argument.\n"
    error.vec <- c(error.vec, msg)
  }

# If a value was not provided for the subpops (subpopulation names) argument,
# assign the value "All_Sites" to the subpops argument and create a factor
# named "All_Sites" in the dframe data frame that takes the value "All Sites"

  if(is.null(subpops)) {
    subpops <- "All_Sites"
    dframe$All_Sites <- "All Sites"
    dframe$All_Sites <- factor(dframe$All_Sites)
  }

# Check input arguments
  temp <- input_check(dframe, design_names, NULL, vars, NULL, NULL, subpops,
    sizeweight, popcorrect, popsize, vartype, conf = 95,  error.ind = error.ind,
    error.vec = error.vec)
  dframe <- temp$dframe
  vars <- temp$vars_cont
  vars_nondetect <- temp$vars_nondetect
  subpops <- temp$subpops
  popsize <- temp$popsize
  vartype <- temp$vartype
  error.ind <- temp$error.ind
  error.vec <- temp$error.vec

# As necessary, output a message indicating that error messages were generated
# during execution of the program

  if(error.ind) {
    error.vec <<- error.vec
    if(length(error.vec) == 1) {
      cat("During execution of the program, an error message was generated.  The error \nmessage is stored in a vector named 'error.vec'.  Enter the following command \nto view the error message: errorprnt()\n")
    } else {
      cat(paste("During execution of the program,", length(error.vec), "error messages were generated.  The error \nmessages are stored in a vector named 'error.vec'.  Enter the following \ncommand to view the error messages: errorprnt()\n"))
    }

    if(warn.ind) {
      warn.df <<- warn.df
      if(nrow(warn.df) == 1) {
        cat("During execution of the program, a warning message was generated.  The warning \nmessage is stored in a data frame named 'warn.df'.  Enter the following command \nto view the warning message: warnprnt()\n")
      } else {
        cat(paste("During execution of the program,", nrow(warn.df), "warning messages were generated.  The warning \nmessages are stored in a data frame named 'warn.df'.  Enter the following \ncommand to view the warning messages: warnprnt() \nTo view a subset of the warning messages (say, messages number 1, 3, and 5), \nenter the following command: warnprnt(m=c(1,3,5))\n"))
      }
    }
    stop("See the preceding message(s).")
  }

# Assign a logical value to the indicator variable for a stratified sample

  stratum.ind <- !is.null(stratumID)

# For a stratified sample, remove strata that contain a single site

  if(stratum.ind) {
    dframe[, stratumID] <- factor(dframe[, stratumID])
    stratum.levels <- levels(dframe[, stratumID])
    nstrata <- length(stratum.levels)
    ind <- FALSE
    for(i in 1:nstrata) {
      tst <- dframe[, stratumID] == stratum.levels[i]
      if(sum(tst) == 1) {
        warn.ind <- TRUE
        warn <- paste0("The stratum named \"", stratum.levels[i], "\" contains a single value and was removed from the analysis.\n")
        act <- "Stratum was removed from the analysis.\n"
        warn.df <- rbind(warn.df, data.frame(func=I(fname), subpoptype=NA,
          subpop=NA, indicator=NA, stratum=NA, warning=I(warn), action=I(act)))
        dframe <- dframe[!tst,]
        ind <- TRUE
      }
    }
    if(ind) {
      dframe[, stratumID] <- factor(dframe[, stratumID])
      stratum.levels <- levels(dframe[, stratumID])
      nstrata <- length(stratum.levels)
      dframe <- droplevels(dframe)
    }
  }

# Assign a logical value to the indicator variable for a two-stage sample

  cluster.ind <- !is.null(clusterID)

# Create the survey design object

  if(stratum.ind) {
    if(cluster.ind) {
      if(sizeweight) {
        dframe$wgt1 <- dframe[, weight1] * dframe[, sweight1]
        dframe$wgt2 <- dframe[, weight] * dframe[, sweight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            strata = make.formula(stratumID),
            nest = TRUE,
            fpc = make.formula(paste(Ncluster, stage1size, sep=" + ")),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            strata = make.formula(stratumID),
            nest = TRUE,
            data = dframe)
        }
      } else {
        dframe$wgt1 <- dframe[, weight1]
        dframe$wgt2 <- dframe[, weight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            strata = make.formula(stratumID),
            nest = TRUE,
            fpc = make.formula(paste(Ncluster, stage1size, sep=" + ")),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            strata = make.formula(stratumID),
            nest = TRUE,
            data = dframe)
        }
      }
    } else {
      if(sizeweight) {
        dframe$wgt <- dframe[, weight] * dframe[, sweight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            strata = make.formula(stratumID),
            fpc = make.formula(fpcsize),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            strata = make.formula(stratumID),
            data = dframe)
        }
      } else {
        dframe$wgt <- dframe[, weight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            strata = make.formula(stratumID),
            fpc = make.formula(fpcsize),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            strata = make.formula(stratumID),
            data = dframe)
        }
      }
    }
  } else {
    if(cluster.ind) {
      if(sizeweight) {
        dframe$wgt1 <- dframe[, weight1] * dframe[, sweight1]
        dframe$wgt2 <- dframe[, weight] * dframe[, sweight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            fpc = make.formula(paste(Ncluster, stage1size, sep=" + ")),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            data = dframe)
        }
      } else {
        dframe$wgt1 <- dframe[, weight1]
        dframe$wgt2 <- dframe[, weight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            fpc = make.formula(paste(Ncluster, stage1size, sep=" + ")),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(paste(clusterID, siteID, sep=" + ")),
            weights = ~wgt1 + wgt2,
            data = dframe)
        }
      }
    } else {
      if(sizeweight) {
        dframe$wgt <- dframe[, weight] * dframe[, sweight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            fpc = make.formula(fpcsize),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            data = dframe)
        }
      } else {
        dframe$wgt <- dframe[, weight]
        if(popcorrect) {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            fpc = make.formula(fpcsize),
            data = dframe)
        } else {
          design <- svydesign(
            ids = make.formula(siteID),
            weights = ~wgt,
            data = dframe)
        }
      }
    }
  }

# If popsize is not equal to NULL, then call either the postStratify or
# calibrate function, as appropriate

  if(!is.null(popsize)) {
    if(all(class(popsize) %in% c("data.frame", "table", "xtabs"))) {
      if("data.frame" %in% class(popsize)) {
        pnames <- names(popsize)[-ncol(popsize)]
      } else {
        pnames <- names(dimnames(popsize))
      }
      design <- postStratify(design, make.formula(pnames), popsize)
    } else {
      cnames <- cal_names(make.formula(names(popsize)), design)
      pop.totals <- numeric(length(cnames))
      names(pop.totals) <- cnames
      pop.totals[1] <-sum(popsize[[1]])
      k <- 2
      for(i in names(popsize)) {
        temp <- popsize[[i]]
        for(j in 2:length(temp)) {
          pop.totals[k] <-temp[j]
          k <- k+1
        }
      }
      design <- calibrate(design, make.formula(cnames), pop.totals)
    }
  }

# If popsize is not equal to NULL and vartype equals "Local", then assign
# adjusted weights to the appropriate weight variable(s) in the design$variables
# data frame

  if(!is.null(popsize) && vartype == "Local") {
    if(cluster.ind) {
      ncluster <- length(unique(design$variables[, clusterID]))
      design$variables$wgt1 <- unique(design$variables[, Ncluster]) / ncluster
      design$variables$wgt2 <- weights(design)/design$variables$wgt1
    } else {
      design$variables$wgt <- weights(design)
    }
  }

# Create the contsum (results) data frame

  contsum <- NULL

# Loop through all subpopulations (domains)

  for(itype in subpops) {

# Identify levels of the subpopulation

    lev_itype <- levels(dframe[, itype])
    nlev_itype <- length(lev_itype)

# Check whether the number of levels of the subpopulation is greater than one

    if(nlev_itype == 1) {
      warn.ind <- TRUE
      warn <- paste("Population type", itype, "contains a single subpopulation. \nNo CDF tests could be performed\n")
      act <- "None.\n"
      warn.df <- rbind(warn.df, data.frame(func=I(fname),
        subpoptype=I(itype), subpop=NA,
        indicator=I(varnames[ivar]), stratum=NA, warning=I(warn),
        action=I(act)))
      next
    }

# Loop through all response variables (vars)

    for(ivar in vars) {

# Determine the set of upper bounds for the response variable

      temp <- dframe[!is.na(dframe[, ivar]), ivar]
      bounds <- sort(temp)[floor(seq(length(temp)/nclass, length(temp),
        length = nclass))]
      design$variables$colvar <- cut(dframe[, ivar], c(-Inf,  bounds))

# Loop through all combinations of levels of the subpopulation

# Begin the loop for the the first level of the combination

      for(isubpop1 in 1:(nlev_itype - 1)) {

# Select sites in the first level

        subpop1.ind <- dframe[, itype] == lev_itype[isubpop1]

# Determine whether the level is empty

        if(all(is.na(dframe[subpop1.ind, ivar]))) {
          warn.ind <- TRUE
          warn <- paste("Subpopulation", lev_itype[isubpop1], "of population type", itype, "for indicator", varnames[ivar], "\ncontains no data.\n")
          act <- "None.\n"
          warn.df <- rbind(warn.df, data.frame(func=I(fname),
            subpoptype=I(itype),
            subpop=I(lev_itype[isubpop1]), indicator=I(varnames[ivar]),
            stratum=NA,  warning=I(warn), action=I(act)))
          next
        }

# Determine whether the level contains a single value

        if(sum(!is.na(dframe[subpop1.ind, ivar])) == 1) {
          warn.ind <- TRUE
          warn <- paste("Subpopulation", lev_itype[isubpop1], "of population type", itype, "for indicator", varnames[ivar], "\ncontains a single value.  No analysis was performed.\n")
          act <- "None.\n"
          warn.df <- rbind(warn.df, data.frame(func=I(fname),
            subpoptype=I(itype),
            subpop=I(lev_itype[isubpop1]), indicator=I(varnames[ivar]),
            stratum=NA,  warning=I(warn), action=I(act)))
          next
        }

# Begin the loop for the second level of the combination

        for(isubpop2 in (isubpop1 + 1):nlev_itype) {

# Select sites in the second level

          subpop2.ind <- dframe[, itype] == lev_itype[isubpop2]

# Determine whether level is empty

          if(all(is.na(dframe[subpop2.ind, ivar]))) {
            warn.ind <- TRUE
            warn <- paste("Subpopulation", lev_itype[isubpop2], "of population type", itype, "for indicator", varnames[ivar], "\ncontains no data.\n")
            act <- "None.\n"
            warn.df <- rbind(warn.df, data.frame(func=I(fname),
              subpoptype=I(itype),
              subpop=I(lev_itype[isubpop2]),
              indicator=I(varnames[ivar]), stratum=NA,  warning=I(warn),
              action=I(act)))
            next
          }

# Determine whether the level contains a single value

          if(sum(!is.na(dframe[subpop2.ind, ivar])) == 1) {
            warn.ind <- TRUE
            warn <- paste("Subpopulation", lev_itype[isubpop2], "of population type", itype, "for indicator", varnames[ivar], "\ncontains a single value.  No analysis was performed.\n")
            act <- "None.\n"
            warn.df <- rbind(warn.df, data.frame(func=I(fname),
              subpoptype=I(itype),
              subpop=I(lev_itype[isubpop2]),
              indicator=I(varnames[ivar]), stratum=NA,  warning=I(warn),
              action=I(act)))
            next
          }

# Perform the CDF test for the response variable

          rowvar <- rep(NA, nrow(dframe))
          rowvar[subpop1.ind] <- "Subpopulation 1"
          rowvar[subpop2.ind] <- "Subpopulation 2"
          design$variables$rowvar <- factor(rowvar,
            levels = c("Subpopulation 1", "Subpopulation 2"))

          if(vartype == "Local") {
            warn.vec <- c(itype, lev_itype[isubpop1], lev_itype[isubpop2], ivar)
            if(testname %in% c("Wald", "adjWald")) {
              temp <- cdftest_localmean_total(design, design_names, popcorrect,
                vartype, warn.ind, warn.df, warn.vec)
              var_totals <- temp$varest
              vartype <- temp$vartype
              warn.ind <- temp$warn.ind
              warn.df <- temp$warn.df
            } else {
              temp <- cdftest_localmean_prop(design, design_names,  popcorrect,
                vartype,  warn.ind, warn.df, warn.vec)
              var_means <- temp$varest
              vartype <- temp$vartype
              warn.ind <- temp$warn.ind
              warn.df <- temp$warn.df
            }
          } else {
            var_totals <- NULL
            var_means <- NULL
          }

          temp <- svychisq_localmean(~rowvar+colvar, design, testname,
            vartype, var_totals, var_means)

# Assign estimates for the response variable to the contsum data frame

          contsum <- rbind(
            contsum,
            data.frame(
              Type = itype,
              Subpopulation_1 = lev_itype[isubpop1],
              Subpopulation_2 = lev_itype[isubpop2],
              Indicator = ivar,
              statistic = temp$statistic,
              Degrees_of_Freedom_1 = temp$parameter[1],
              Degrees_of_Freedom_2 = temp$parameter[2],
              p_Value = temp$p.value))

# End of the loops for combinations of levels of the subpopulation

        }
      }

# End of the loop for response variables

    }

# End of the loop for subpopulations

  }

# Assign a value for the column in the output data frame that contains test
# statistic values

  if(testname == "Wald") {
    names(contsum)[5] <- "Wald Statistic"
  } else if(testname == "adjWald") {
    names(contsum)[5] <- "Adjusted Wald Statistic"
  } else if(testname == "Chisq") {
    names(contsum)[5] <- "Rao-Scott First Order Statistic"
  } else {
    names(contsum)[5] <- "Rao-Scott Second Order Statistic"
  }

# As necessary, modify dimension names

  row.names(contsum) <- 1:nrow(contsum)
  if(testname == "Chisq") {
    contsum <- contsum[, -7]
    names(contsum)[6] <- "Degrees_of_Freedom"
  }

# As necessary, output a message indicating that warning messages were generated
# during execution of the program

  if(warn.ind) {
    warn.df <<- warn.df
    if(nrow(warn.df) == 1)
      cat("During execution of the program, a warning message was generated.  The warning \nmessage is stored in a data frame named 'warn.df'.  Enter the following command \nto view the warning message: warnprnt()\n")
    else
      cat(paste("During execution of the program,", nrow(warn.df), "warning messages were generated.  The warning \nmessages are stored in a data frame named 'warn.df'.  Enter the following \ncommand to view the warning messages: warnprnt() \nTo view a subset of the warning messages (say, messages number 1, 3, and 5), \nenter the following command: warnprnt(m=c(1,3,5))\n"))
  }

# Return the data frame

  contsum
}
